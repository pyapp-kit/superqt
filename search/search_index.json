{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"superqt","text":""},{"location":"#missing-widgets-and-components-for-pyqtpyside","title":"\"missing\" widgets and components for PyQt/PySide","text":"<p>This repository aims to provide high-quality community-contributed Qt widgets and components for PyQt &amp; PySide that are not provided in the native QtWidgets module.</p> <p>Components are tested on:</p> <ul> <li>macOS, Windows, &amp; Linux</li> <li>Python 3.9 and above</li> <li>PyQt5 (5.11 and above) &amp; PyQt6</li> <li>PySide2 (5.11 and above) &amp; PySide6</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install superqt\n</code></pre> <pre><code>conda install -c conda-forge superqt\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See the Widgets and Utilities pages for features offered by superqt.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#sliders-not-dragging-properly-on-macos-12","title":"Sliders not dragging properly on MacOS 12+","text":"Details <p>On MacOS Monterey, with Qt5, there is a bug that causes all sliders (including native Qt sliders) to not respond properly to drag events.  See:</p> <ul> <li>https://bugreports.qt.io/browse/QTBUG-98093</li> <li>https://github.com/pyapp-kit/superqt/issues/74</li> </ul> <p>Superqt includes a workaround for this issue, but it is not perfect, and it requires using a custom stylesheet (which may interfere with your own styles).  Note that you may not see this issue if you're already using custom stylesheets.</p> <p>To opt in to the workaround, do any of the following:</p> <ul> <li>set the environment variable <code>USE_MAC_SLIDER_PATCH=1</code> before importing superqt (note: this is safe to use even if you're targeting more than just MacOS 12, it will only be applied when needed)</li> <li>call the <code>applyMacStylePatch()</code> method on any of the superqt slider subclasses (note, this will override your slider styles)</li> <li>apply the stylesheet manually:</li> </ul> <pre><code>from superqt.sliders import MONTEREY_SLIDER_STYLES_FIX\n\nslider.setStyleSheet(MONTEREY_SLIDER_STYLES_FIX)\n</code></pre>"},{"location":"utilities/","title":"Utilities","text":""},{"location":"utilities/#font-icons","title":"Font Icons","text":"Object Description <code>addFont</code> Add an <code>OTF/TTF</code> file at to the font registry. <code>font</code> Create <code>QFont</code> for a given font-icon font family key <code>icon</code> Create a <code>QIcon</code> for font-con glyph key <code>setTextIcon</code> Set text on a <code>QWidget</code> to a specific font &amp; glyph. <code>IconFont</code> Helper class that provides a standard way to create an <code>IconFont</code>. <code>IconOpts</code> Options for rendering an icon <code>Animation</code> Base class for adding animations to a font-icon."},{"location":"utilities/#svg-icons","title":"SVG Icons","text":"Object Description <code>QIconifyIcon</code> QIcons backed by the Iconify icon library."},{"location":"utilities/#threading-tools","title":"Threading tools","text":"Object Description <code>ensure_main_thread</code> Decorator that ensures a function is called in the main <code>QApplication</code> thread. <code>ensure_object_thread</code> Decorator that ensures a <code>QObject</code> method is called in the object's thread. <code>FunctionWorker</code> <code>QRunnable</code> with signals that wraps a simple long-running function. <code>GeneratorWorker</code> <code>QRunnable</code> with signals that wraps a long-running generator. <code>create_worker</code> Create a worker to run a target function in another thread. <code>thread_worker</code> Decorator for <code>create_worker</code>, turn a function into a worker."},{"location":"utilities/#miscellaneous","title":"Miscellaneous","text":"Object Description <code>QMessageHandler</code> A context manager to intercept messages from Qt. <code>CodeSyntaxHighlight</code> A <code>QSyntaxHighlighter</code> for code syntax highlighting. <code>draw_colormap</code> Function that draws a colormap into any QPaintDevice."},{"location":"utilities/cmap/","title":"Colormap utilities","text":"<p>See also:</p> <ul> <li><code>superqt.QColormapComboBox</code></li> <li><code>superqt.cmap.CmapCatalogComboBox</code></li> </ul>"},{"location":"utilities/cmap/#superqt.cmap.draw_colormap","title":"<code>superqt.cmap.draw_colormap(painter_or_device, cmap, rect=None, border_color=None, border_width=1, lighter=100, checkerboard_size=4)</code>","text":"<p>Draw a colormap onto a QPainter or QPaintDevice.</p> <p>Parameters:</p> Name Type Description Default <code>painter_or_device</code> <code>QPainter | QPaintDevice</code> <p>A <code>QPainter</code> instance or a <code>QPaintDevice</code> (e.g. a QWidget or QPixmap) onto which to paint the colormap.</p> required <code>cmap</code> <code>Colormap | Any</code> <p><code>cmap.Colormap</code> instance, or anything that can be converted to one (such as a string name of a colormap in the <code>cmap</code> catalog). https://cmap-docs.readthedocs.io/en/latest/colormaps/#colormaplike-objects</p> required <code>rect</code> <code>QRect | QRectF | None</code> <p>A rect onto which to draw. If <code>None</code>, the <code>painter.viewport()</code> will be used.  by default <code>None</code></p> <code>None</code> <code>border_color</code> <code>QColor | str | None</code> <p>If not <code>None</code>, a border of color <code>border_color</code> and width <code>border_width</code> is included around the edge, by default None.</p> <code>None</code> <code>border_width</code> <code>int</code> <p>The width of the border to draw (provided <code>border_color</code> is not <code>None</code>), by default 2</p> <code>1</code> <code>lighter</code> <code>int</code> <p>Percentage by which to lighten (or darken) the colors. Greater than 100 lightens, less than 100 darkens, by default 100 (i.e. no change).</p> <code>100</code> <code>checkerboard_size</code> <code>bool</code> <p>Size (in pixels) of the checkerboard pattern to draw, by default 5. If 0, no checkerboard is drawn.</p> <code>4</code> <p>Examples:</p> <pre><code>from qtpy.QtGui import QPixmap\nfrom qtpy.QtWidgets import QWidget\nfrom superqt.utils import draw_colormap\n\nviridis = \"viridis\"  # or cmap.Colormap('viridis')\n\n\nclass W(QWidget):\n    def paintEvent(self, event) -&gt; None:\n        draw_colormap(self, viridis, event.rect())\n\n\n# or draw onto a QPixmap\npm = QPixmap(200, 200)\ndraw_colormap(pm, viridis)\n</code></pre>"},{"location":"utilities/cmap/#superqt.cmap.QColormapLineEdit","title":"<code>superqt.cmap.QColormapLineEdit</code>","text":"<p>               Bases: <code>QLineEdit</code></p> <p>A QLineEdit that shows a colormap swatch.</p> <p>When the current text is a valid colormap name from the <code>cmap</code> package, a swatch of the colormap will be shown to the left of the text (if <code>fractionalColormapWidth</code> is less than .75) or behind the text (for when the colormap fills the full width).</p> <p>If the current text is not a valid colormap name, a swatch of the fallback colormap will be shown instead (by default, a gray colormap) if <code>fractionalColormapWidth</code> is less than .75.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget.</p> <code>None</code> <code>fractional_colormap_width</code> <code>float</code> <p>The fraction of the widget width to use for the colormap swatch. If the colormap is full width (greater than 0.75), the swatch will be drawn behind the text. Otherwise, the swatch will be drawn to the left of the text. Default is 0.33.</p> <code>0.33</code> <code>fallback_cmap</code> <code>Colormap | str | None</code> <p>The colormap to use when the current text is not a recognized colormap. by default \"gray\".</p> <code>'gray'</code> <code>missing_icon</code> <code>QIcon | StandardPixmap</code> <p>The icon to show when the current text is not a recognized colormap and <code>fractionalColormapWidth</code> is less than .75. Default is a question mark.</p> <code>MISSING</code> <code>checkerboard_size</code> <code>int</code> <p>Size (in pixels) of the checkerboard pattern to draw behind colormaps with transparency, by default 4. If 0, no checkerboard is drawn.</p> <code>4</code>"},{"location":"utilities/cmap/#superqt.cmap.QColormapItemDelegate","title":"<code>superqt.cmap.QColormapItemDelegate</code>","text":"<p>               Bases: <code>QStyledItemDelegate</code></p> <p>Delegate that draws colormaps into a QAbstractItemView item.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QObject</code> <p>The parent object.</p> <code>None</code> <code>item_size</code> <code>QSize</code> <p>The size hint for each item, by default QSize(80, 22).</p> <code>DEFAULT_SIZE</code> <code>fractional_colormap_width</code> <code>float</code> <p>The fraction of the widget width to use for the colormap swatch. If the colormap is full width (greater than 0.75), the swatch will be drawn behind the text. Otherwise, the swatch will be drawn to the left of the text. Default is 0.33.</p> <code>1</code> <code>padding</code> <code>int</code> <p>The padding (in pixels) around the edge of the item, by default 1.</p> <code>1</code> <code>checkerboard_size</code> <code>int</code> <p>Size (in pixels) of the checkerboard pattern to draw behind colormaps with transparency, by default 4. If 0, no checkerboard is drawn.</p> <code>4</code>"},{"location":"utilities/code_syntax_highlight/","title":"CodeSyntaxHighlight","text":"<p>A code highlighter subclass of <code>QSyntaxHighlighter</code> that can be used to highlight code in a QTextEdit.</p> <p>Code lexer and available styles are from <code>pygments</code> python library</p> <p>List of available languages are available here.</p> <p>List of available styles are available here.</p>"},{"location":"utilities/code_syntax_highlight/#example","title":"Example","text":"<pre><code>from qtpy.QtGui import QColor, QPalette\nfrom qtpy.QtWidgets import QApplication, QTextEdit\n\nfrom superqt.utils import CodeSyntaxHighlight\n\napp = QApplication([])\n\ntext_area = QTextEdit()\n\nhighlight = CodeSyntaxHighlight(text_area.document(), \"python\", \"monokai\")\n\npalette = text_area.palette()\npalette.setColor(QPalette.Base, QColor(highlight.background_color))\ntext_area.setPalette(palette)\ntext_area.setText(\n    \"\"\"from argparse import ArgumentParser\n\ndef main():\n    parser = ArgumentParser()\n    parser.add_argument(\"name\", help=\"Your name\")\n    args = parser.parse_args()\n    print(f\"Hello {args.name}\")\n\n\nif __name__ == \"__main__\":\n    main()\n\"\"\"\n)\n\ntext_area.show()\ntext_area.resize(400, 200)\n\napp.exec_()\n</code></pre>"},{"location":"utilities/code_syntax_highlight/#qt-class","title":"Qt Class","text":"<p><code>QSyntaxHighlighter</code></p>"},{"location":"utilities/code_syntax_highlight/#methods","title":"Methods","text":"<p>A syntax highlighter for code using Pygments.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QTextDocument | QObject | None</code> <p>The parent object. Usually a QTextDocument.  To use this class with a QTextArea, pass in <code>text_area.document()</code>.</p> required <code>lang</code> <code>str</code> <p>The language of the code to highlight. This should be a string that Pygments recognizes, e.g. 'python', 'pytb', 'cpp', 'java', etc.</p> required <code>theme</code> <code>KnownStyle | str</code> <p>The name of the Pygments style to use. For a complete list of available styles, use <code>pygments.styles.get_all_styles()</code>.</p> <code>'default'</code> <p>Examples:</p> <pre><code>from qtpy.QtWidgets import QTextEdit\nfrom superqt.utils import CodeSyntaxHighlight\n\ntext_area = QTextEdit()\nhighlighter = CodeSyntaxHighlight(text_area.document(), \"python\", \"monokai\")\n\n# then manually apply the background color to the text area.\npalette = text_area.palette()\nbgrd_color = QColor(self._highlight.background_color)\npalette.setColor(QPalette.ColorRole.Base, bgrd_color)\ntext_area.setPalette(palette)\n</code></pre>"},{"location":"utilities/code_syntax_highlight/#superqt.utils.CodeSyntaxHighlight.background_color","title":"<code>background_color: str</code>  <code>property</code>","text":""},{"location":"utilities/code_syntax_highlight/#superqt.utils.CodeSyntaxHighlight.setLanguage","title":"<code>setLanguage(lang: str) -&gt; None</code>","text":"<p>Set the language for the syntax highlighting.</p> <p>This should be a string that Pygments recognizes, e.g. 'python', 'pytb', 'cpp', 'java', etc.</p>"},{"location":"utilities/code_syntax_highlight/#superqt.utils.CodeSyntaxHighlight.setTheme","title":"<code>setTheme(theme: KnownStyle | str) -&gt; None</code>","text":"<p>Set the theme for the syntax highlighting.</p> <p>This should be a string that Pygments recognizes, e.g. 'monokai', 'solarized'. Use <code>pygments.styles.get_all_styles()</code> to see a list of available styles.</p>"},{"location":"utilities/error_dialog_contexts/","title":"Error message context manager","text":""},{"location":"utilities/error_dialog_contexts/#superqt.utils.exceptions_as_dialog","title":"<code>superqt.utils.exceptions_as_dialog</code>","text":"<p>Context manager that shows a dialog when an exception is raised.</p> <p>See examples below for common usage patterns.</p> <p>To determine whether an exception was raised or not, check the <code>exception</code> attribute after the context manager has exited.  If <code>use_error_message</code> is <code>False</code> (the default), you can also access the <code>dialog</code> attribute to get/manipulate the <code>QMessageBox</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>exceptions</code> <code>type[BaseException] | tuple[type[BaseException], ...]</code> <p>The exception(s) to catch, by default <code>Exception</code> (i.e. all exceptions).</p> <code>Exception</code> <code>icon</code> <code>Icon</code> <p>The icon to show in the QMessageBox, by default <code>QMessageBox.Icon.Critical</code></p> <code>Critical</code> <code>title</code> <code>str</code> <p>The title of the <code>QMessageBox</code>, by default <code>\"An error occurred\"</code>.</p> <code>'An error occurred'</code> <code>msg_template</code> <code>str</code> <p>The message to show in the <code>QMessageBox</code>. The message will be formatted using three variables:</p> <ul> <li><code>exc_value</code>: the exception instance</li> <li><code>exc_type</code>: the exception type</li> <li><code>tb</code>: the traceback as a string</li> </ul> <p>The default template is the content of the exception: <code>\"{exc_value}\"</code></p> <code>'{exc_value}'</code> <code>buttons</code> <code>StandardButton</code> <p>The buttons to show in the <code>QMessageBox</code>, by default <code>QMessageBox.StandardButton.Ok</code></p> <code>Ok</code> <code>parent</code> <code>QWidget | None</code> <p>The parent widget of the <code>QMessageBox</code>, by default <code>None</code></p> <code>None</code> <code>use_error_message</code> <code>bool | QErrorMessage</code> <p>Whether to use a <code>QErrorMessage</code> instead of a <code>QMessageBox</code>. By default <code>False</code>. <code>QErrorMessage</code> shows a checkbox that the user can check to prevent seeing the message again (based on the text of the formatted <code>msg_template</code>.) If <code>True</code>, the global <code>QMessageError.qtHandler()</code> instance is used to maintain a history of dismissed messages. You may also pass a <code>QErrorMessage</code> instance to use a specific instance. If <code>use_error_message</code> is True, or if you pass your own <code>QErrorMessage</code> instance, the <code>parent</code> argument is ignored.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>dialog</code> <code>QMessageBox | None</code> <p>The <code>QMessageBox</code> instance that was created (if <code>use_error_message</code> was <code>False</code>).  This can be used, among other things, to determine the result of the dialog (e.g. <code>dialog.result()</code>) or to manipulate the dialog (e.g. <code>dialog.setDetailedText(\"some text\")</code>).</p> <code>exception</code> <code>BaseException | None</code> <p>Will hold the exception instance if an exception was raised and caught.</p> <p>Examples:</p> <pre><code>from qtpy.QtWidgets import QApplication\nfrom superqt.utils import exceptions_as_dialog\n\napp = QApplication([])\n\nwith exceptions_as_dialog() as ctx:\n    raise Exception(\"This will be caught and shown in a QMessageBox\")\n\n# you can access the exception instance here\nassert ctx.exception is not None\n\n# with exceptions_as_dialog(ValueError):\n#     1 / 0  # ZeroDivisionError is not caught, so this will raise\n\nwith exceptions_as_dialog(msg_template=\"Error: {exc_value}\"):\n    raise Exception(\"This message will be inserted at 'exc_value'\")\n\nfor _i in range(3):\n    with exceptions_as_dialog(AssertionError, use_error_message=True):\n        assert False, \"Uncheck the checkbox to ignore this in the future\"\n\n# use ctx.dialog to get the result of the dialog\nbtns = QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel\nwith exceptions_as_dialog(buttons=btns) as ctx:\n    raise Exception(\"This will be caught and shown in a QMessageBox\")\nprint(ctx.dialog.result())  # prints which button was clicked\n\napp.exec()  # needed only for the use_error_message example to show\n</code></pre>"},{"location":"utilities/fonticon/","title":"Font icons","text":"<p>The <code>superqt.fonticon</code> module provides a set of utilities for working with font icons such as Font Awesome or Material Design Icons.</p>"},{"location":"utilities/fonticon/#basic-example","title":"Basic Example","text":"<pre><code>from fonticon_fa5 import FA5S\n\nfrom qtpy.QtCore import QSize\nfrom qtpy.QtWidgets import QApplication, QPushButton\n\nfrom superqt.fonticon import icon, pulse\n\napp = QApplication([])\n\nbtn2 = QPushButton()\nbtn2.setIcon(icon(FA5S.smile, color=\"blue\"))\nbtn2.setIconSize(QSize(225, 225))\nbtn2.show()\n\napp.exec()\n</code></pre>"},{"location":"utilities/fonticon/#font-icon-plugins","title":"Font Icon plugins","text":"<p>Ready-made fonticon packs are available as plugins.</p> <p>A great way to search across most available icons libraries from a single search interface is to use glyphsearch: https://glyphsearch.com/</p> <p>If a font library you'd like to use is unavailable as a superqt plugin, please open a feature request</p>"},{"location":"utilities/fonticon/#font-awesome-6","title":"Font Awesome 6","text":"<p>Browse available icons at https://fontawesome.com/v6/search</p> <pre><code>pip install fonticon-fontawesome6\n</code></pre>"},{"location":"utilities/fonticon/#font-awesome-5","title":"Font Awesome 5","text":"<p>Browse available icons at https://fontawesome.com/v5/search</p> <pre><code>pip install fonticon-fontawesome5\n</code></pre>"},{"location":"utilities/fonticon/#material-design-icons-7","title":"Material Design Icons 7","text":"<p>Browse available icons at https://materialdesignicons.com/</p> <pre><code>pip install fonticon-materialdesignicons7\n</code></pre>"},{"location":"utilities/fonticon/#material-design-icons-6","title":"Material Design Icons 6","text":"<p>Browse available icons at https://materialdesignicons.com/ (note that the search defaults to v7, see changes from v6 in the changelog)</p> <pre><code>pip install fonticon-materialdesignicons6\n</code></pre>"},{"location":"utilities/fonticon/#see-also","title":"See also","text":"<ul> <li>https://github.com/tlambert03/fonticon-bootstrapicons</li> <li>https://github.com/tlambert03/fonticon-linearicons</li> <li>https://github.com/tlambert03/fonticon-feather</li> </ul> <p><code>superqt.fonticon</code> is a pluggable system, and font icon packs may use the <code>\"superqt.fonticon\"</code> entry point to register themselves with superqt. See <code>fonticon-cookiecutter</code> for a template, or look through the following repos for examples:</p> <ul> <li>https://github.com/tlambert03/fonticon-fontawesome6</li> <li>https://github.com/tlambert03/fonticon-fontawesome5</li> <li>https://github.com/tlambert03/fonticon-materialdesignicons6</li> </ul>"},{"location":"utilities/fonticon/#api","title":"API","text":"<p>options: heading_level: 3</p> <p>options: heading_level: 3</p> <p>options: heading_level: 3</p> <p>options: heading_level: 3</p> <p>options: heading_level: 3</p>"},{"location":"utilities/fonticon/#superqt.fonticon.icon","title":"<code>superqt.fonticon.icon(glyph_key, scale_factor=DEFAULT_SCALING_FACTOR, color=None, opacity=1, animation=None, transform=None, states=None)</code>","text":"<p>Create a QIcon for <code>glyph_key</code>, with a number of optional settings.</p> <p>The <code>glyph_key</code> (e.g. 'fa5s.smile') represents a Font-family &amp; style, and a glyph. In most cases, the key should be provided by a plugin in the environment, like:</p> <ul> <li>fonticon-fontawesome5 ('fa5s' &amp;   'fa5r' prefixes)</li> <li>fonticon-materialdesignicons6   ('mdi6' prefix)</li> </ul> <p>...but fonts can also be added manually using <code>addFont</code>.</p> <p>Parameters:</p> Name Type Description Default <code>glyph_key</code> <code>str</code> <p>String encapsulating a font-family, style, and glyph. e.g. 'fa5s.smile'.</p> required <code>scale_factor</code> <code>float</code> <p>Scale factor (fraction of widget height), When widget icon is painted on widget, it will use <code>font.setPixelSize(round(wdg.height() * scale_factor))</code>. by default 0.875.</p> <code>DEFAULT_SCALING_FACTOR</code> <code>color</code> <code>ValidColor</code> <p>Color for the font, by default None. (e.g. The default <code>QColor</code>) Valid color types include <code>QColor</code>, <code>int</code>, <code>str</code>, <code>Qt.GlobalColor</code>, <code>tuple</code> (of integer: RGB[A]) (anything that can be passed to <code>QColor</code>).</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Opacity of icon, by default 1</p> <code>1</code> <code>animation</code> <code>Animation</code> <p>Animation for the icon.  A subclass of superqt.fonticon.Animation, that provides a concrete <code>animate</code> method. (see \"spin\" and \"pulse\" for examples). by default None.</p> <code>None</code> <code>transform</code> <code>QTransform</code> <p>A <code>QTransform</code> to apply when painting the icon, by default None</p> <code>None</code> <code>states</code> <code>dict</code> <p>Provide additional styling for the icon in different states.  <code>states</code> must be a mapping of string to dict, where:</p> <ul> <li>the key represents a <code>QIcon.State</code> (\"on\", \"off\"), a <code>QIcon.Mode</code> (\"normal\",   \"active\", \"selected\", \"disabled\"), or any combination of a state &amp; mode   separated by an underscore (e.g. \"off_active\", \"selected_on\", etc...).</li> <li>the value is a dict with all of the same key/value meanings listed above as   parameters to this function (e.g. <code>glyph_key</code>, <code>color</code>,<code>scale_factor</code>,   <code>animation</code>, etc...)</li> </ul> <p>Missing keys in the state dicts will be taken from the default options, provided by the parameters above.</p> <code>None</code> <p>Returns:</p> Type Description <code>QFontIcon</code> <p>A subclass of QIcon.  Can be used wherever QIcons are used, such as <code>widget.setIcon()</code></p> <p>Examples:</p> <p>simple example (using the string <code>'fa5s.smile'</code> assumes the <code>fonticon-fontawesome5</code> plugin is installed)</p> <pre><code>&gt;&gt;&gt; btn = QPushButton()\n&gt;&gt;&gt; btn.setIcon(icon(\"fa5s.smile\"))\n</code></pre> <p>can also directly import from fonticon_fa5</p> <pre><code>&gt;&gt;&gt; from fonticon_fa5 import FA5S\n&gt;&gt;&gt; btn.setIcon(icon(FA5S.smile))\n</code></pre> <p>with animation</p> <pre><code>&gt;&gt;&gt; btn2 = QPushButton()\n&gt;&gt;&gt; btn2.setIcon(icon(FA5S.spinner, animation=pulse(btn2)))\n</code></pre> <p>complicated example</p> <pre><code>&gt;&gt;&gt; btn = QPushButton()\n&gt;&gt;&gt; btn.setIcon(\n...     icon(\n...         FA5S.ambulance,\n...         color=\"blue\",\n...         states={\n...             \"active\": {\n...                 \"glyph\": FA5S.bath,\n...                 \"color\": \"red\",\n...                 \"scale_factor\": 0.5,\n...                 \"animation\": pulse(btn),\n...             },\n...             \"disabled\": {\n...                 \"color\": \"green\",\n...                 \"scale_factor\": 0.8,\n...                 \"animation\": spin(btn),\n...             },\n...         },\n...     )\n... )\n&gt;&gt;&gt; btn.setIconSize(QSize(256, 256))\n&gt;&gt;&gt; btn.show()\n</code></pre>"},{"location":"utilities/fonticon/#superqt.fonticon.setTextIcon","title":"<code>superqt.fonticon.setTextIcon(widget, glyph_key, size=None)</code>","text":"<p>Set text on a widget to a specific font &amp; glyph.</p> <p>This is an alternative to setting a QIcon with a pixmap.  It may be easier to combine with dynamic stylesheets.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>QWidget</code> <p>A widget supporting a <code>setText</code> method.</p> required <code>glyph_key</code> <code>str</code> <p>String encapsulating a font-family, style, and glyph. e.g. 'fa5s.smile'.</p> required <code>size</code> <code>int</code> <p>Size for QFont.  passed to <code>setPixelSize</code>, by default None</p> <code>None</code>"},{"location":"utilities/fonticon/#superqt.fonticon.font","title":"<code>superqt.fonticon.font(font_prefix, size=None)</code>","text":"<p>Create QFont for <code>font_prefix</code>.</p> <p>Parameters:</p> Name Type Description Default <code>font_prefix</code> <code>str</code> <p>Font_prefix, such as 'fa5s' or 'mdi6', representing a font-family and style.</p> required <code>size</code> <code>int</code> <p>Size for QFont.  passed to <code>setPixelSize</code>, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>QFont</code> <p>QFont instance that can be used to add fonticons to widgets.</p>"},{"location":"utilities/fonticon/#superqt.fonticon.IconOpts","title":"<code>superqt.fonticon.IconOpts</code>  <code>dataclass</code>","text":"<p>Options for rendering an icon.</p> <p>Parameters:</p> Name Type Description Default <code>glyph_key</code> <code>str</code> <p>The key of the glyph to use, e.g. <code>'fa5s.smile'</code>, by default <code>None</code></p> <code>_Unset</code> <code>scale_factor</code> <code>float</code> <p>The scale factor to use, by default <code>None</code></p> <code>_Unset</code> <code>color</code> <code>ValidColor</code> <p>The color to use, by default <code>None</code>. Colors may be specified as a string, <code>QColor</code>, <code>Qt.GlobalColor</code>, or a 3 or 4-tuple of integers.</p> <code>_Unset</code> <code>opacity</code> <code>float</code> <p>The opacity to use, by default <code>None</code></p> <code>_Unset</code> <code>animation</code> <code>Animation</code> <p>The animation to use, by default <code>None</code></p> <code>_Unset</code>"},{"location":"utilities/fonticon/#superqt.fonticon.addFont","title":"<code>superqt.fonticon.addFont(filepath, prefix, charmap=None)</code>","text":"<p>Add OTF/TTF file at <code>filepath</code> to the registry under <code>prefix</code>.</p> <p>If you'd like to later use a fontkey in the form of <code>prefix.some-name</code>, then <code>charmap</code> must be provided and provide a mapping for all of the glyph names to their unicode numbers. If a charmap is not provided, glyphs must be directly accessed with their unicode as something like <code>key.\uffff</code>.</p> <p>Note</p> <p>in most cases, users will not need this. Instead, they should install a font plugin, like:</p> <ul> <li>fonticon-fontawesome5</li> <li>fonticon-materialdesignicons6</li> </ul> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to an OTF or TTF file containing the fonts</p> required <code>prefix</code> <code>str</code> <p>A prefix that will represent this font file when used for lookup.  For example, 'fa5s' for 'Font-Awesome 5 Solid'.</p> required <code>charmap</code> <code>Dict[str, str]</code> <p>optional mapping for all of the glyph names to their unicode numbers. See note above.</p> <code>None</code> <p>Returns:</p> Type Description <code>(Tuple[str, str], optional)</code> <p>font-family and font-style for the file just registered, or <code>None</code> if something goes wrong.</p>"},{"location":"utilities/fonticon/#animations","title":"Animations","text":"<p>the <code>animation</code> parameter to <code>icon()</code> accepts a subclass of <code>Animation</code> that will be</p> <p>options: heading_level: 3</p> <p>options: heading_level: 3</p> <p>options: heading_level: 3</p>"},{"location":"utilities/fonticon/#superqt.fonticon.Animation","title":"<code>superqt.fonticon.Animation</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base icon animation class.</p>"},{"location":"utilities/fonticon/#superqt.fonticon.Animation.animate","title":"<code>animate(painter)</code>  <code>abstractmethod</code>","text":"<p>Setup and start the timer for the animation.</p>"},{"location":"utilities/fonticon/#superqt.fonticon.pulse","title":"<code>superqt.fonticon.pulse</code>","text":"<p>               Bases: <code>spin</code></p> <p>Animation that spins an icon in slower, discrete steps.</p>"},{"location":"utilities/fonticon/#superqt.fonticon.spin","title":"<code>superqt.fonticon.spin</code>","text":"<p>               Bases: <code>Animation</code></p> <p>Animation that smoothly spins an icon.</p>"},{"location":"utilities/iconify/","title":"QIconifyIcon","text":"<p>Iconify is an icon library that includes 150,000+ icons from most major icon sets including Bootstrap, FontAwesome, Material Design, and many more; each available as individual SVGs.  Unlike the <code>superqt.fonticon</code> module, <code>superqt.QIconifyIcon</code> does not require any additional dependencies or font files to be installed.  Icons are downloaded (and cached) on-demand from the Iconify API, using pyconify</p> <p>Search availble icons at https://icon-sets.iconify.design Once you find one you like, use the key in the format <code>\"prefix:name\"</code> to create an icon:  <code>QIconifyIcon(\"bi:bell\")</code>.</p>"},{"location":"utilities/iconify/#basic-example","title":"Basic Example","text":"<pre><code>from qtpy.QtCore import QSize\nfrom qtpy.QtWidgets import QApplication, QPushButton\n\nfrom superqt import QIconifyIcon\n\napp = QApplication([])\n\nbtn = QPushButton()\nbtn.setIcon(QIconifyIcon(\"fluent-emoji-flat:alarm-clock\"))\nbtn.setIconSize(QSize(60, 60))\nbtn.show()\n\napp.exec()\n</code></pre>"},{"location":"utilities/iconify/#superqt.QIconifyIcon","title":"<code>superqt.QIconifyIcon</code>","text":"<p>               Bases: <code>QIcon</code></p> <p>QIcon backed by an iconify icon.</p> <p>Iconify includes 150,000+ icons from most major icon sets including Bootstrap, FontAwesome, Material Design, and many more.</p> <p>Search availble icons at https://icon-sets.iconify.design Once you find one you like, use the key in the format <code>\"prefix:name\"</code> to create an icon:  <code>QIconifyIcon(\"bi:bell\")</code>.</p> <p>This class is a thin wrapper around the pyconify <code>svg_path</code> function. It pulls SVGs from iconify, creates a temporary SVG file and uses it as the source for a QIcon. SVGs are cached to disk, and persist across sessions (until <code>pyconify.clear_cache()</code> is called).</p> <p>Parameters are the same as <code>QIconifyIcon.addKey</code>, which can be used to add additional icons for various modes and states to the same QIcon.</p> <p>Parameters:</p> Name Type Description Default <code>*key</code> <code>str</code> <p>Icon set prefix and name. May be passed as a single string in the format <code>\"prefix:name\"</code> or as two separate strings: <code>'prefix', 'name'</code>.</p> <code>()</code> <code>color</code> <code>str</code> <p>Icon color. If not provided, the icon will appear black (the icon fill color will be set to the string \"currentColor\").</p> <code>None</code> <code>flip</code> <code>str</code> <p>Flip icon.  Must be one of \"horizontal\", \"vertical\", \"horizontal,vertical\"</p> <code>None</code> <code>rotate</code> <code>str | int</code> <p>Rotate icon. Must be one of 0, 90, 180, 270, or 0, 1, 2, 3 (equivalent to 0, 90, 180, 270, respectively)</p> <code>None</code> <code>dir</code> <code>str</code> <p>If 'dir' is not None, the file will be created in that directory, otherwise a default directory is used.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from qtpy.QtWidgets import QPushButton\n&gt;&gt;&gt; from superqt import QIconifyIcon\n&gt;&gt;&gt; btn = QPushButton()\n&gt;&gt;&gt; icon = QIconifyIcon(\"bi:alarm-fill\", color=\"red\", rotate=90)\n&gt;&gt;&gt; btn.setIcon(icon)\n</code></pre>"},{"location":"utilities/iconify/#superqt.QIconifyIcon.addKey","title":"<code>addKey(*key, color=None, flip=None, rotate=None, dir=None, size=None, mode=QIcon.Mode.Normal, state=QIcon.State.Off)</code>","text":"<p>Add an icon to this QIcon.</p> <p>This is a variant of <code>QIcon.addFile</code> that uses an iconify icon keys and arguments instead of a file path.</p> <p>Parameters:</p> Name Type Description Default <code>*key</code> <code>str</code> <p>Icon set prefix and name. May be passed as a single string in the format <code>\"prefix:name\"</code> or as two separate strings: <code>'prefix', 'name'</code>.</p> <code>()</code> <code>color</code> <code>str</code> <p>Icon color. If not provided, the icon will appear black (the icon fill color will be set to the string \"currentColor\").</p> <code>None</code> <code>flip</code> <code>str</code> <p>Flip icon.  Must be one of \"horizontal\", \"vertical\", \"horizontal,vertical\"</p> <code>None</code> <code>rotate</code> <code>str | int</code> <p>Rotate icon. Must be one of 0, 90, 180, 270, or 0, 1, 2, 3 (equivalent to 0, 90, 180, 270, respectively)</p> <code>None</code> <code>dir</code> <code>str</code> <p>If 'dir' is not None, the file will be created in that directory, otherwise a default directory is used.</p> <code>None</code> <code>size</code> <code>QSize</code> <p>Size specified for the icon, passed to <code>QIcon.addFile</code>.</p> <code>None</code> <code>mode</code> <code>Mode</code> <p>Mode specified for the icon, passed to <code>QIcon.addFile</code>.</p> <code>Normal</code> <code>state</code> <code>State</code> <p>State specified for the icon, passed to <code>QIcon.addFile</code>.</p> <code>Off</code> <p>Returns:</p> Type Description <code>QIconifyIcon</code> <p>This QIconifyIcon instance, for chaining.</p>"},{"location":"utilities/qmessagehandler/","title":"QMessageHandler","text":""},{"location":"utilities/qmessagehandler/#superqt.utils.QMessageHandler","title":"<code>superqt.utils.QMessageHandler</code>","text":"<p>A context manager to intercept messages from Qt.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>Logger</code> <p>If provided, intercepted messages will be logged with <code>logger</code> at the corresponding python log level, by default None</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>records</code> <code>list of tuple</code> <p>Captured messages. This is a 3-tuple of: <code>(log_level: int, message: str, context: dict)</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; handler = QMessageHandler()\n&gt;&gt;&gt; handler.install()  # now all Qt output will be available at mh.records\n</code></pre> <pre><code>&gt;&gt;&gt; with QMessageHandler() as handler:  # temporarily install\n...     ...\n</code></pre> <pre><code>&gt;&gt;&gt; logger = logging.getLogger(__name__)\n&gt;&gt;&gt; with QMessageHandler(logger):  # re-reoute Qt messages to a python logger.\n...     ...\n</code></pre>"},{"location":"utilities/qmessagehandler/#superqt.utils.QMessageHandler.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter a context with this handler installed.</p>"},{"location":"utilities/qmessagehandler/#superqt.utils.QMessageHandler.install","title":"<code>install()</code>","text":"<p>Install this handler (override the current QtMessageHandler).</p>"},{"location":"utilities/qmessagehandler/#superqt.utils.QMessageHandler.uninstall","title":"<code>uninstall()</code>","text":"<p>Uninstall this handler, restoring the previous handler.</p>"},{"location":"utilities/signal_utils/","title":"Signal Utilities","text":""},{"location":"utilities/signal_utils/#superqt.utils.signals_blocked","title":"<code>superqt.utils.signals_blocked(obj)</code>","text":"<p>Context manager to temporarily block signals emitted by QObject: <code>obj</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>QObject</code> <p>The QObject whose signals should be blocked.</p> required <p>Examples:</p> <pre><code>from qtpy.QtWidgets import QSpinBox\nfrom superqt import signals_blocked\n\nspinbox = QSpinBox()\nwith signals_blocked(spinbox):\n    spinbox.setValue(10)\n</code></pre>"},{"location":"utilities/thread_decorators/","title":"Threading decorators","text":"<p><code>superqt</code> provides two decorators that help to ensure that given function is running in the desired thread:</p>"},{"location":"utilities/thread_decorators/#ensure_main_thread","title":"<code>ensure_main_thread</code>","text":"<p><code>ensure_main_thread</code> ensures that the decorated function/method runs in the main thread</p>"},{"location":"utilities/thread_decorators/#ensure_object_thread","title":"<code>ensure_object_thread</code>","text":"<p><code>ensure_object_thread</code> ensures that a decorated bound method of a <code>QObject</code> runs in the thread in which the instance lives (see qt documentation for details).</p>"},{"location":"utilities/thread_decorators/#usage","title":"Usage","text":"<p>By default, functions are executed asynchronously (they return immediately with an instance of <code>concurrent.futures.Future</code>).</p> <p>To block and wait for the result, see Synchronous mode</p> <pre><code>from qtpy.QtCore import QObject\nfrom superqt import ensure_main_thread, ensure_object_thread\n\n@ensure_main_thread\ndef sample_function():\n    print(\"This function will run in main thread\")\n\n\nclass SampleObject(QObject):\n    def __init__(self):\n        super().__init__()\n        self._value = 1\n\n    @ensure_main_thread\n    def sample_method1(self):\n        print(\"This method will run in main thread\")\n\n    @ensure_object_thread\n    def sample_method3(self):\n        import time\n        print(\"sleeping\")\n        time.sleep(1)\n        print(\"This method will run in object thread\")\n\n    @property\n    def value(self):\n        print(\"return value\")\n        return self._value\n\n    @value.setter\n    @ensure_object_thread\n    def value(self, value):\n        print(\"this setter will run in object thread\")\n        self._value = value\n</code></pre> <p>As can be seen in this example these decorators can also be used for setters.</p> <p>These decorators should not be used as replacement of Qt Signals but rather to interact with Qt objects from non Qt code.</p>"},{"location":"utilities/thread_decorators/#synchronous-mode","title":"Synchronous mode","text":"<p>If you'd like for the program to block and wait for the result of your function call, use the <code>await_return=True</code> parameter, and optionally specify a timeout.</p> <p>Important</p> <p>Using synchronous mode may significantly impact performance.</p> <pre><code>from superqt import ensure_main_thread\n\n@ensure_main_thread\ndef sample_function1():\n    return 1\n\n@ensure_main_thread(await_return=True)\ndef sample_function2():\n    return 2\n\nassert sample_function1() is None\nassert sample_function2() == 2\n\n# optionally, specify a timeout\n@ensure_main_thread(await_return=True, timeout=10000)\ndef sample_function():\n    return 1\n</code></pre>"},{"location":"utilities/threading/","title":"Thread workers","text":"<p>The objects in this module provide utilities for running tasks in a separate thread. In general (with the exception of <code>new_worker_qthread</code>), everything here wraps Qt's QRunnable API.</p> <p>The highest level object is the <code>@thread_worker</code> decorator.  It was originally written for <code>napari</code>, and was later extracted into <code>superqt</code>.  You may also be interested in reading the napari documentation on this feature, which provides a more in-depth/introductory usage guide.</p> <p>For additional control, you can create your own <code>FunctionWorker</code> or <code>GeneratorWorker</code> objects.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase","title":"<code>superqt.utils.WorkerBase</code>","text":"<p>               Bases: <code>QRunnable</code>, <code>Generic[_R]</code></p> <p>Base class for creating a Worker that can run in another thread.</p> <p>Parameters:</p> Name Type Description Default <code>SignalsClass</code> <code>type</code> <p>A QObject subclass that contains signals, by default WorkerBaseSignals</p> <code>WorkerBaseSignals</code> <p>Attributes:</p> Name Type Description <code>signals</code> <code>WorkerBaseSignals</code> <p>signal emitter object. To allow identify which worker thread emitted signal.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.abort_requested","title":"<code>abort_requested</code>  <code>property</code>","text":"<p>Whether the worker has been requested to stop.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Whether the worker has been started.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Pass through attr requests to signals to simplify connection API.</p> <p>The goal is to enable <code>worker.yielded.connect</code> instead of <code>worker.signals.yielded.connect</code>. Because multiple inheritance of Qt classes is not well supported in PyQt, we have to use composition here (signals are provided by QObjects, and QRunnable is not a QObject). So this passthrough allows us to connect to signals on the <code>_signals</code> object.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.await_workers","title":"<code>await_workers(msecs=None)</code>  <code>classmethod</code>","text":"<p>Ask all workers to quit, and wait up to <code>msec</code> for quit.</p> <p>Attempts to clean up all running workers by calling <code>worker.quit()</code> method.  Any workers in the <code>WorkerBase._worker_set</code> set will have this method.</p> <p>By default, this function will block indefinitely, until worker threads finish.  If a timeout is provided, a <code>RuntimeError</code> will be raised if the workers do not gracefully exit in the time requests, but the threads will NOT be killed.  It is (currently) left to the user to use their OS to force-quit rogue threads.</p> <p>Important</p> <p>If the user does not put any yields in their function, and the function is super long, it will just hang... For instance, there's no graceful way to kill this thread in python:</p> <pre><code>@thread_worker\ndef ZZZzzz():\n    time.sleep(10000000)\n</code></pre> <p>This is why it's always advisable to use a generator that periodically yields for long-running computations in another thread.</p> <p>See this stack-overflow post for a good discussion on the difficulty of killing a rogue python thread:</p> <p>Parameters:</p> Name Type Description Default <code>msecs</code> <code>int</code> <p>Waits up to msecs milliseconds for all threads to exit and removes all threads from the thread pool. If msecs is <code>None</code> (the default), the timeout is ignored (waits for the last thread to exit).</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a timeout is provided and workers do not quit successfully within the time allotted.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.quit","title":"<code>quit()</code>","text":"<p>Send a request to abort the worker.</p> <p>Note</p> <p>It is entirely up to subclasses to honor this method by checking <code>self.abort_requested</code> periodically in their <code>worker.work</code> method, and exiting if <code>True</code>.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.run","title":"<code>run()</code>","text":"<p>Start the worker.</p> <p>The end-user should never need to call this function. But it cannot be made private or renamed, since it is called by Qt.</p> <p>The order of method calls when starting a worker is:</p> <pre><code>   calls QThreadPool.globalInstance().start(worker)\n   |               triggered by the QThreadPool.start() method\n   |               |             called by worker.run\n   |               |             |\n   V               V             V\n   worker.start -&gt; worker.run -&gt; worker.work\n</code></pre> <p>This is the function that actually gets called when calling <code>QThreadPool.start(worker)</code>.  It simply wraps the <code>work()</code> method, and emits a few signals.  Subclasses should NOT override this method (except with good reason), and instead should implement <code>work()</code>.</p>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.start","title":"<code>start()</code>","text":"<p>Start this worker in a thread and add it to the global threadpool.</p> <p>The order of method calls when starting a worker is:</p> <pre><code>   calls QThreadPool.globalInstance().start(worker)\n   |               triggered by the QThreadPool.start() method\n   |               |             called by worker.run\n   |               |             |\n   V               V             V\n   worker.start -&gt; worker.run -&gt; worker.work\n</code></pre>"},{"location":"utilities/threading/#superqt.utils.WorkerBase.work","title":"<code>work()</code>","text":"<p>Main method to execute the worker.</p> <p>The end-user should never need to call this function. But subclasses must implement this method (See <code>GeneratorFunction.work</code> for an example implementation). Minimally, it should check <code>self.abort_requested</code> periodically and exit if True.</p> <p>Examples:</p> <pre><code>class MyWorker(WorkerBase):\n    def work(self):\n        i = 0\n        while True:\n            if self.abort_requested:\n                self.aborted.emit()\n                break\n            i += 1\n            if i &gt; max_iters:\n                break\n            time.sleep(0.5)\n</code></pre>"},{"location":"utilities/threading/#superqt.utils.FunctionWorker","title":"<code>superqt.utils.FunctionWorker</code>","text":"<p>               Bases: <code>WorkerBase[_R]</code></p> <p>QRunnable with signals that wraps a simple long-running function.</p> <p>Note</p> <p><code>FunctionWorker</code> does not provide a way to stop a very long-running function (e.g. <code>time.sleep(10000)</code>).  So whenever possible, it is better to implement your long running function as a generator that yields periodically, and use the <code>GeneratorWorker</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A function to call in another thread</p> required <code>*args</code> <p>will be passed to the function</p> <code>()</code> <code>**kwargs</code> <p>will be passed to the function</p> <code>{}</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>func</code> is a generator function and not a regular function.</p>"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker","title":"<code>superqt.utils.GeneratorWorker</code>","text":"<p>               Bases: <code>WorkerBase</code>, <code>Generic[_Y, _S, _R]</code></p> <p>QRunnable with signals that wraps a long-running generator.</p> <p>Provides a convenient way to run a generator function in another thread, while allowing 2-way communication between threads, using plain-python generator syntax in the original function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>callable</code> <p>The function being run in another thread.  May be a generator function.</p> required <code>SignalsClass</code> <code>type</code> <p>A QObject subclass that contains signals, by default GeneratorWorkerSignals</p> <code>GeneratorWorkerSignals</code> <code>*args</code> <p>Will be passed to func on instantiation</p> <code>()</code> <code>**kwargs</code> <p>Will be passed to func on instantiation</p> <code>{}</code>"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker.is_paused","title":"<code>is_paused</code>  <code>property</code>","text":"<p>Whether the worker is currently paused.</p>"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker.pause","title":"<code>pause()</code>","text":"<p>Request to pause the worker.</p>"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker.resume","title":"<code>resume()</code>","text":"<p>Send a request to resume the worker.</p>"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker.send","title":"<code>send(value)</code>","text":"<p>Send a value into the function (if a generator was used).</p>"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker.toggle_pause","title":"<code>toggle_pause()</code>","text":"<p>Request to pause the worker if playing or resume if paused.</p>"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker.work","title":"<code>work()</code>","text":"<p>Core event loop that calls the original function.</p> <p>Enters a continual loop, yielding and returning from the original function.  Checks for various events (quit, pause, resume, etc...). (To clarify: we are creating a rudimentary event loop here because there IS NO Qt event loop running in the other thread to hook into)</p>"},{"location":"utilities/threading/#convenience-functions","title":"Convenience functions","text":""},{"location":"utilities/threading/#superqt.utils.thread_worker","title":"<code>superqt.utils.thread_worker(function=None, start_thread=None, connect=None, worker_class=None, ignore_errors=False)</code>","text":"<pre><code>thread_worker(\n    function: Callable[_P, Generator[_Y, _S, _R]],\n    start_thread: bool | None = None,\n    connect: dict[str, Callable | Sequence[Callable]]\n    | None = None,\n    worker_class: type[WorkerBase] | None = None,\n    ignore_errors: bool = False,\n) -&gt; Callable[_P, GeneratorWorker[_Y, _S, _R]]\n</code></pre><pre><code>thread_worker(\n    function: Callable[_P, _R],\n    start_thread: bool | None = None,\n    connect: dict[str, Callable | Sequence[Callable]]\n    | None = None,\n    worker_class: type[WorkerBase] | None = None,\n    ignore_errors: bool = False,\n) -&gt; Callable[_P, FunctionWorker[_R]]\n</code></pre><pre><code>thread_worker(\n    function: Literal[None] = None,\n    start_thread: bool | None = None,\n    connect: dict[str, Callable | Sequence[Callable]]\n    | None = None,\n    worker_class: type[WorkerBase] | None = None,\n    ignore_errors: bool = False,\n) -&gt; Callable[\n    [Callable],\n    Callable[_P, FunctionWorker | GeneratorWorker],\n]\n</code></pre> <p>Decorator that runs a function in a separate thread when called.</p> <p>When called, the decorated function returns a <code>WorkerBase</code>.  See <code>create_worker</code> for additional keyword arguments that can be used when calling the function.</p> <p>The returned worker will have these signals:</p> <ul> <li>started: emitted when the work is started</li> <li>finished: emitted when the work is finished</li> <li>returned: emitted with return value</li> <li>errored: emitted with error object on Exception</li> </ul> <p>It will also have a <code>worker.start()</code> method that can be used to start execution of the function in another thread. (useful if you need to connect callbacks to signals prior to execution)</p> <p>If the decorated function is a generator, the returned worker will also provide these signals:</p> <ul> <li>yielded: emitted with yielded values</li> <li>paused: emitted when a running job has successfully paused</li> <li>resumed: emitted when a paused job has successfully resumed</li> <li>aborted: emitted when a running job is successfully aborted</li> </ul> <p>And these methods:</p> <ul> <li>quit: ask the thread to quit</li> <li>toggle_paused: toggle the running state of the thread.</li> <li>send: send a value into the generator.  (This requires that your   decorator function uses the <code>value = yield</code> syntax)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>callable</code> <p>Function to call in another thread.  For communication between threads may be a generator function.</p> <code>None</code> <code>start_thread</code> <code>bool</code> <p>Whether to immediaetly start the thread.  If False, the returned worker must be manually started with <code>worker.start()</code>. by default it will be <code>False</code> if the <code>_connect</code> argument is <code>None</code>, otherwise <code>True</code>.</p> <code>None</code> <code>connect</code> <code>Dict[str, Union[Callable, Sequence]]</code> <p>A mapping of <code>\"signal_name\"</code> -&gt; <code>callable</code> or list of <code>callable</code>: callback functions to connect to the various signals offered by the worker class. by default None</p> <code>None</code> <code>worker_class</code> <code>Type[WorkerBase]</code> <p>The <code>WorkerBase</code> to instantiate, by default <code>FunctionWorker</code> will be used if <code>func</code> is a regular function, and <code>GeneratorWorker</code> will be used if it is a generator.</p> <code>None</code> <code>ignore_errors</code> <code>bool</code> <p>If <code>False</code> (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier).</p> <code>False</code> <p>Returns:</p> Type Description <code>callable</code> <p>function that creates a worker, puts it in a new thread and returns the worker instance.</p> <p>Examples:</p> <pre><code>@thread_worker\ndef long_function(start, end):\n    # do work, periodically yielding\n    i = start\n    while i &lt;= end:\n        time.sleep(0.1)\n        yield i\n\n    # do teardown\n    return \"anything\"\n\n\n# call the function to start running in another thread.\nworker = long_function()\n\n# connect signals here if desired... or they may be added using the\n# `connect` argument in the `@thread_worker` decorator... in which\n# case the worker will start immediately when long_function() is called\nworker.start()\n</code></pre>"},{"location":"utilities/threading/#superqt.utils.create_worker","title":"<code>superqt.utils.create_worker(func, *args, _start_thread=None, _connect=None, _worker_class=None, _ignore_errors=False, **kwargs)</code>","text":"<pre><code>create_worker(\n    func: Callable[_P, Generator[_Y, _S, _R]],\n    *args,\n    _start_thread: bool | None = None,\n    _connect: dict[str, Callable | Sequence[Callable]]\n    | None = None,\n    _worker_class: type[GeneratorWorker]\n    | type[FunctionWorker]\n    | None = None,\n    _ignore_errors: bool = False,\n    **kwargs,\n) -&gt; GeneratorWorker[_Y, _S, _R]\n</code></pre><pre><code>create_worker(\n    func: Callable[_P, _R],\n    *args,\n    _start_thread: bool | None = None,\n    _connect: dict[str, Callable | Sequence[Callable]]\n    | None = None,\n    _worker_class: type[GeneratorWorker]\n    | type[FunctionWorker]\n    | None = None,\n    _ignore_errors: bool = False,\n    **kwargs,\n) -&gt; FunctionWorker[_R]\n</code></pre> <p>Convenience function to start a function in another thread.</p> <p>By default, uses <code>FunctionWorker</code> for functions and <code>GeneratorWorker</code> for generators, but a custom <code>WorkerBase</code> subclass may be provided.  If so, it must be a subclass of <code>WorkerBase</code>, which defines a standard set of signals and a run method.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>The function to call in another thread.</p> required <code>_start_thread</code> <code>bool</code> <p>Whether to immediaetly start the thread.  If False, the returned worker must be manually started with <code>worker.start()</code>. by default it will be <code>False</code> if the <code>_connect</code> argument is <code>None</code>, otherwise <code>True</code>.</p> <code>None</code> <code>_connect</code> <code>Dict[str, Union[Callable, Sequence]]</code> <p>A mapping of <code>\"signal_name\"</code> -&gt; <code>callable</code> or list of <code>callable</code>: callback functions to connect to the various signals offered by the worker class. by default <code>None</code></p> <code>None</code> <code>_worker_class</code> <code>type of `GeneratorWorker` or `FunctionWorker`</code> <p>The <code>WorkerBase</code> to instantiate, by default <code>FunctionWorker</code> will be used if <code>func</code> is a regular function, and <code>GeneratorWorker</code> will be used if it is a generator.</p> <code>None</code> <code>_ignore_errors</code> <code>bool</code> <p>If <code>False</code> (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier).</p> <code>False</code> <code>*args</code> <p>will be passed to <code>func</code></p> <code>()</code> <code>**kwargs</code> <p>will be passed to <code>func</code></p> <code>{}</code> <p>Returns:</p> Name Type Description <code>worker</code> <code>WorkerBase</code> <p>An instantiated worker.  If <code>_start_thread</code> was <code>False</code>, the worker will have a <code>.start()</code> method that can be used to start the thread.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If a worker_class is provided that is not a subclass of WorkerBase.</p> <code>TypeError</code> <p>If _connect is provided and is not a dict of <code>{str: callable}</code></p> <p>Examples:</p> <pre><code>def long_function(duration):\n    import time\n\n    time.sleep(duration)\n\n\nworker = create_worker(long_function, 10)\n</code></pre>"},{"location":"utilities/threading/#superqt.utils.new_worker_qthread","title":"<code>superqt.utils.new_worker_qthread(Worker, *args, _start_thread=False, _connect=None, **kwargs)</code>","text":"<p>Convenience function to start a worker in a <code>QThread</code>.</p> <p>thread, not as the actual code or object that runs in that thread.  The QThread object is created on the main thread and lives there.</p> <p>Worker objects which derive from QObject are the things that actually do the work. They can be moved to a QThread as is done here.</p> Mostly ignorable detail <p>While the signals/slots syntax of the worker looks very similar to standard \"single-threaded\" signals &amp; slots, note that inter-thread signals and slots (automatically) use an event-based QueuedConnection, while intra-thread signals use a DirectConnection. See Signals and Slots Across Threads</p> <p>Parameters:</p> Name Type Description Default <code>Worker</code> <code>QObject</code> <p>QObject type that implements a <code>work()</code> method.  The Worker should also emit a finished signal when the work is done.</p> required <code>_start_thread</code> <code>bool</code> <p>If True, thread will be started immediately, otherwise, thread must be manually started with thread.start().</p> <code>False</code> <code>_connect</code> <code>dict</code> <p>Optional dictionary of {signal: function} to connect to the new worker. for instance:  _connect = {'incremented': myfunc} will result in: worker.incremented.connect(myfunc)</p> <code>None</code> <code>*args</code> <p>will be passed to the Worker class on instantiation.</p> <code>()</code> <code>**kwargs</code> <p>will be passed to the Worker class on instantiation.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>worker</code> <code>WorkerBase</code> <p>The created worker.</p> <code>thread</code> <code>QThread</code> <p>The thread on which the worker is running.</p> <p>Examples:</p> <p>Create some QObject that has a long-running work method:</p> <pre><code>class Worker(QObject):\n    finished = Signal()\n    increment = Signal(int)\n\n    def __init__(self, argument):\n        super().__init__()\n        self.argument = argument\n\n    @Slot()\n    def work(self):\n        # some long running task...\n        import time\n\n        for i in range(10):\n            time.sleep(1)\n            self.increment.emit(i)\n        self.finished.emit()\n\n\nworker, thread = new_worker_qthread(\n    Worker,\n    \"argument\",\n    _start_thread=True,\n    _connect={\"increment\": print},\n)\n</code></pre>"},{"location":"utilities/throttling/","title":"Throttling &amp; Debouncing","text":"<p>These utilities allow you to throttle or debounce a function. This is useful when you have a function that is called multiple times in a short period of time, and you want to make sure it is only \"actually\" called once (or at least no more than a certain frequency).</p> <p>For background on throttling and debouncing, see:</p> <ul> <li>https://blog.openreplay.com/forever-functional-debouncing-and-throttling-for-performance</li> <li>https://css-tricks.com/debouncing-throttling-explained-examples/</li> </ul>"},{"location":"utilities/throttling/#superqt.utils.qdebounced","title":"<code>superqt.utils.qdebounced(func=None, timeout=100, leading=False, timer_type=Qt.TimerType.PreciseTimer, parent=None)</code>","text":"<pre><code>qdebounced(\n    func: Callable[P, R],\n    timeout: int = 100,\n    leading: bool = False,\n    timer_type: Qt.TimerType = Qt.TimerType.PreciseTimer,\n    parent: QObject | None = None,\n) -&gt; ThrottledCallable[P, R]\n</code></pre><pre><code>qdebounced(\n    func: None = ...,\n    timeout: int = 100,\n    leading: bool = False,\n    timer_type: Qt.TimerType = Qt.TimerType.PreciseTimer,\n    parent: QObject | None = None,\n) -&gt; Callable[[Callable[P, R]], ThrottledCallable[P, R]]\n</code></pre> <p>Creates a debounced function that delays invoking <code>func</code>.</p> <p><code>func</code> will not be invoked until <code>timeout</code> ms have elapsed since the last time the debounced function was invoked.</p> <p>The debounced function comes with a <code>cancel</code> method to cancel delayed func invocations and a <code>flush</code> method to immediately invoke them. Options indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last <code>func</code> invocation.</p> <p>This decorator may be used with or without parameters.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A function to throttle</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in milliseconds to wait before allowing another call, by default 100</p> <code>100</code> <code>leading</code> <code>bool</code> <p>Whether to invoke the function on the leading edge of the wait timer, by default False</p> <code>False</code> <code>timer_type</code> <code>TimerType</code> <p>The timer type. by default <code>Qt.TimerType.PreciseTimer</code> One of:     - <code>Qt.PreciseTimer</code>: Precise timers try to keep millisecond accuracy     - <code>Qt.CoarseTimer</code>: Coarse timers try to keep accuracy within 5% of the       desired interval     - <code>Qt.VeryCoarseTimer</code>: Very coarse timers only keep full second accuracy</p> <code>PreciseTimer</code> <code>parent</code> <code>QObject | None</code> <p>Parent object for timer. If using qthrottled as function it may be usefull for cleaning data</p> <code>None</code>"},{"location":"utilities/throttling/#superqt.utils.qthrottled","title":"<code>superqt.utils.qthrottled(func=None, timeout=100, leading=True, timer_type=Qt.TimerType.PreciseTimer, parent=None)</code>","text":"<pre><code>qthrottled(\n    func: Callable[P, R],\n    timeout: int = 100,\n    leading: bool = True,\n    timer_type: Qt.TimerType = Qt.TimerType.PreciseTimer,\n    parent: QObject | None = None,\n) -&gt; ThrottledCallable[P, R]\n</code></pre><pre><code>qthrottled(\n    func: None = ...,\n    timeout: int = 100,\n    leading: bool = True,\n    timer_type: Qt.TimerType = Qt.TimerType.PreciseTimer,\n    parent: QObject | None = None,\n) -&gt; Callable[[Callable[P, R]], ThrottledCallable[P, R]]\n</code></pre> <p>Creates a throttled function that invokes func at most once per timeout.</p> <p>The throttled function comes with a <code>cancel</code> method to cancel delayed func invocations and a <code>flush</code> method to immediately invoke them. Options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the throttled function. Subsequent calls to the throttled function return the result of the last func invocation.</p> <p>This decorator may be used with or without parameters.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>A function to throttle</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Timeout in milliseconds to wait before allowing another call, by default 100</p> <code>100</code> <code>leading</code> <code>bool</code> <p>Whether to invoke the function on the leading edge of the wait timer, by default True</p> <code>True</code> <code>timer_type</code> <code>TimerType</code> <p>The timer type. by default <code>Qt.TimerType.PreciseTimer</code> One of:     - <code>Qt.PreciseTimer</code>: Precise timers try to keep millisecond accuracy     - <code>Qt.CoarseTimer</code>: Coarse timers try to keep accuracy within 5% of the       desired interval     - <code>Qt.VeryCoarseTimer</code>: Very coarse timers only keep full second accuracy</p> <code>PreciseTimer</code> <code>parent</code> <code>QObject | None</code> <p>Parent object for timer. If using qthrottled as function it may be usefull for cleaning data</p> <code>None</code>"},{"location":"utilities/throttling/#superqt.utils.QSignalDebouncer","title":"<code>superqt.utils.QSignalDebouncer</code>","text":"<p>               Bases: <code>GenericSignalThrottler</code></p> <p>A Signal Debouncer.</p> <p>This object's <code>triggered</code> signal will not be emitted until <code>self.timeout()</code> milliseconds have elapsed since the last time <code>triggered</code> was emitted.</p>"},{"location":"utilities/throttling/#superqt.utils.QSignalThrottler","title":"<code>superqt.utils.QSignalThrottler</code>","text":"<p>               Bases: <code>GenericSignalThrottler</code></p> <p>A Signal Throttler.</p> <p>This object's <code>triggered</code> signal will emit at most once per timeout (set with setTimeout()).</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler","title":"<code>superqt.utils._throttler.GenericSignalThrottler</code>","text":"<p>               Bases: <code>QObject</code></p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.cancel","title":"<code>cancel()</code>","text":"<p>Cancel any pending emissions.</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.emissionPolicy","title":"<code>emissionPolicy()</code>","text":"<p>Return the emission policy (trailing or leading).</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.flush","title":"<code>flush(restart_timer=True)</code>","text":"<p>Force emission of any pending emissions.</p> <p>Parameters:</p> Name Type Description Default <code>restart_timer</code> <code>bool</code> <p>Whether to restart the timer after flushing. Defaults to True.</p> <code>True</code>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.kind","title":"<code>kind()</code>","text":"<p>Return the kind of throttler (throttler or debouncer).</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.setTimeout","title":"<code>setTimeout(timeout)</code>","text":"<p>Set timeout in milliseconds.</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.setTimerType","title":"<code>setTimerType(timerType)</code>","text":"<p>Set current Qt.TimerType.</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.throttle","title":"<code>throttle()</code>","text":"<p>Emit triggered if not running, then start timer.</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.timeout","title":"<code>timeout()</code>","text":"<p>Return current timeout in milliseconds.</p>"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.timerType","title":"<code>timerType()</code>","text":"<p>Return current <code>Qt.TimerType</code>.</p>"},{"location":"widgets/","title":"Widgets","text":"<p>The following are QWidget subclasses:</p>"},{"location":"widgets/#sliders-and-numerical-inputs","title":"Sliders and Numerical Inputs","text":"Widget Description <code>QDoubleRangeSlider</code> Multi-handle slider for float values <code>QDoubleSlider</code> Slider for float values <code>QLabeledDoubleRangeSlider</code> <code>QDoubleRangeSlider</code> variant with editable labels for each handle <code>QLabeledDoubleSlider</code> <code>QSlider</code> for float values with editable <code>QSpinBox</code> with the current value <code>QLabeledRangeSlider</code> <code>QRangeSlider</code> variant, with editable labels for each handle <code>QLabeledSlider</code> <code>QSlider</code> with editable <code>QSpinBox</code> that shows the current value <code>QLargeIntSpinBox</code> <code>QSpinbox</code> that accepts arbitrarily large integers <code>QRangeSlider</code> Multi-handle slider <code>QQuantity</code> Pint-backed quantity widget (magnitude combined with unit dropdown)"},{"location":"widgets/#labels-and-categorical-inputs","title":"Labels and categorical inputs","text":"Widget Description <code>QElidingLabel</code> A <code>QLabel</code> variant that will elide text (add <code>\u2026</code>) to fit width. <code>QEnumComboBox</code> <code>QComboBox</code> that populates the combobox from a python <code>Enum</code> <code>QSearchableComboBox</code> <code>QComboBox</code> variant that filters available options based on text input <code>QSearchableListWidget</code> <code>QListWidget</code> variant with search field that filters available options <code>QSearchableTreeWidget</code> <code>QTreeWidget</code> variant with search field that filters available options <code>QColorComboBox</code> <code>QComboBox</code> to select from a specified set of colors <code>QColormapComboBox</code> <code>QComboBox</code> to select from a specified set of colormaps."},{"location":"widgets/#frames-and-containers","title":"Frames and containers","text":"Widget Description <code>QCollapsible</code> A collapsible widget to hide and unhide child widgets. <code>QFlowLayout</code> A layout that rearranges items based on parent width."},{"location":"widgets/colormap_catalog/","title":"CmapCatalogComboBox","text":"<p>Searchable <code>QComboBox</code> variant that contains the entire cmap colormap catalog</p> <p>requires cmap</p> <p>This widget uses the cmap library to provide colormaps.  You can install it with:</p> <pre><code># use the `cmap` extra to include colormap support\npip install superqt[cmap]\n</code></pre> <p>You can limit the colormaps shown by setting the <code>categories</code> or <code>interpolation</code> keyword arguments.</p> <pre><code>from qtpy.QtWidgets import QApplication\n\nfrom superqt.cmap import CmapCatalogComboBox\n\napp = QApplication([])\n\ncatalog_combo = CmapCatalogComboBox(interpolation=\"linear\")\ncatalog_combo.setCurrentText(\"viridis\")\ncatalog_combo.show()\n\napp.exec()\n</code></pre> <p></p>"},{"location":"widgets/colormap_catalog/#qt-class","title":"Qt Class","text":"<p><code>QComboBox</code></p>"},{"location":"widgets/colormap_catalog/#signals","title":"Signals","text":""},{"location":"widgets/colormap_catalog/#currentcolormapchanged","title":"<code>currentColormapChanged</code>","text":""},{"location":"widgets/colormap_catalog/#methods","title":"Methods","text":"<p>A combo box for selecting a colormap from the entire cmap catalog.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget.</p> <code>None</code> <code>prefer_short_names</code> <code>bool</code> <p>If True (default), short names (without the namespace prefix) will be preferred over fully qualified names. In cases where the same short name is used in multiple namespaces, they will all be referred to by their fully qualified (namespaced) name.</p> <code>True</code> <code>categories</code> <code>Container[Category]</code> <p>If provided, only return names from the given categories.</p> <code>()</code> <code>interpolation</code> <code>Interpolation</code> <p>If provided, only return names that have the given interpolation method.</p> <code>None</code>"},{"location":"widgets/colormap_catalog/#superqt.cmap.CmapCatalogComboBox.currentColormap","title":"<code>currentColormap() -&gt; Colormap | None</code>","text":"<p>Returns the currently selected Colormap or None if not yet selected.</p>"},{"location":"widgets/qcollapsible/","title":"QCollapsible","text":"<p>Collapsible <code>QFrame</code> that can be expanded or collapsed by clicking on the header.</p> <pre><code>from qtpy.QtWidgets import QApplication, QLabel, QPushButton\n\nfrom superqt import QCollapsible\n\napp = QApplication([])\n\ncollapsible = QCollapsible(\"Advanced analysis\")\ncollapsible.addWidget(QLabel(\"This is the inside of the collapsible frame\"))\nfor i in range(10):\n    collapsible.addWidget(QPushButton(f\"Content button {i + 1}\"))\n\ncollapsible.expand(animate=False)\ncollapsible.show()\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qcollapsible/#qt-class","title":"Qt Class","text":"<p><code>QFrame</code></p>"},{"location":"widgets/qcollapsible/#signals","title":"Signals","text":""},{"location":"widgets/qcollapsible/#toggled","title":"<code>toggled</code>","text":""},{"location":"widgets/qcollapsible/#methods","title":"Methods","text":"<p>A collapsible widget to hide and unhide child widgets.</p> <p>A signal is emitted when the widget is expanded (True) or collapsed (False).</p> <p>Based on https://stackoverflow.com/a/68141638</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.addWidget","title":"<code>addWidget(widget: QWidget) -&gt; None</code>","text":"<p>Add a widget to the central content widget's layout.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.collapse","title":"<code>collapse(animate: bool = True) -&gt; None</code>","text":"<p>Collapse (hide) the collapsible section.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.collapsedIcon","title":"<code>collapsedIcon() -&gt; QIcon</code>","text":"<p>Returns the icon used when the widget is collapsed.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.content","title":"<code>content() -&gt; QWidget</code>","text":"<p>Return the current content widget.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.expand","title":"<code>expand(animate: bool = True) -&gt; None</code>","text":"<p>Expand (show) the collapsible section.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.expandedIcon","title":"<code>expandedIcon() -&gt; QIcon</code>","text":"<p>Returns the icon used when the widget is expanded.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.isExpanded","title":"<code>isExpanded() -&gt; bool</code>","text":"<p>Return whether the collapsible section is visible.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.locked","title":"<code>locked() -&gt; bool</code>","text":"<p>Return True if collapse/expand is disabled.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.removeWidget","title":"<code>removeWidget(widget: QWidget) -&gt; None</code>","text":"<p>Remove widget from the central content widget's layout.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.setCollapsedIcon","title":"<code>setCollapsedIcon(icon: QIcon | str | None = None) -&gt; None</code>","text":"<p>Set the icon on the toggle button when the widget is collapsed.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.setContent","title":"<code>setContent(content: QWidget) -&gt; None</code>","text":"<p>Replace central widget (the widget that gets expanded/collapsed).</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.setDuration","title":"<code>setDuration(msecs: int) -&gt; None</code>","text":"<p>Set duration of the collapse/expand animation.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.setEasingCurve","title":"<code>setEasingCurve(easing: QEasingCurve | QEasingCurve.Type) -&gt; None</code>","text":"<p>Set the easing curve for the collapse/expand animation.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.setExpandedIcon","title":"<code>setExpandedIcon(icon: QIcon | str | None = None) -&gt; None</code>","text":"<p>Set the icon on the toggle button when the widget is expanded.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.setLocked","title":"<code>setLocked(locked: bool = True) -&gt; None</code>","text":"<p>Set whether collapse/expand is disabled.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.setText","title":"<code>setText(text: str) -&gt; None</code>","text":"<p>Set the text of the toggle button.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.text","title":"<code>text() -&gt; str</code>","text":"<p>Return the text of the toggle button.</p>"},{"location":"widgets/qcollapsible/#superqt.QCollapsible.toggleButton","title":"<code>toggleButton() -&gt; QPushButton</code>","text":"<p>Return the toggle button.</p>"},{"location":"widgets/qcolorcombobox/","title":"QColorComboBox","text":"<p><code>QComboBox</code> designed to select from a specific set of colors.</p> <pre><code>from qtpy.QtWidgets import QApplication\n\nfrom superqt import QColorComboBox\n\napp = QApplication([])\n\ncolors = QColorComboBox()\ncolors.addColors(['red', 'green', 'blue'])\n\n# show an \"Add Color\" item that opens a QColorDialog when clicked\ncolors.setUserColorsAllowed(True)\n\n# emits a QColor when changed\ncolors.currentColorChanged.connect(print)\ncolors.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qcolorcombobox/#qt-class","title":"Qt Class","text":"<p><code>QComboBox</code></p>"},{"location":"widgets/qcolorcombobox/#signals","title":"Signals","text":""},{"location":"widgets/qcolorcombobox/#currentcolorchanged","title":"<code>currentColorChanged</code>","text":""},{"location":"widgets/qcolorcombobox/#enums","title":"Enums","text":""},{"location":"widgets/qcolorcombobox/#qcolorcomboboxinvalidcolorpolicy","title":"<code>QColorComboBox.InvalidColorPolicy</code>","text":"<ul> <li> <p><code>Ignore</code></p> </li> <li> <p><code>Warn</code></p> </li> <li> <p><code>Raise</code></p> </li> </ul>"},{"location":"widgets/qcolorcombobox/#methods","title":"Methods","text":"<p>A drop down menu for selecting colors.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget.</p> <code>None</code> <code>allow_user_colors</code> <code>bool</code> <p>Whether to show an \"Add Color\" item that opens a QColorDialog when clicked. Whether the user can add custom colors by clicking the \"Add Color\" item. Default is False. Can also be set with <code>setUserColorsAllowed</code>.</p> <code>False</code> <code>add_color_text</code> <code>str</code> <p>The text to display for the \"Add Color\" item. Default is \"Add Color...\".</p> <code>'Add Color...'</code>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.addColor","title":"<code>addColor(color: Any) -&gt; None</code>","text":"<p>Adds the color to the QComboBox.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.addColors","title":"<code>addColors(colors: Sequence[Any]) -&gt; None</code>","text":"<p>Adds colors to the QComboBox.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.currentColor","title":"<code>currentColor() -&gt; QColor | None</code>","text":"<p>Returns the currently selected QColor or None if not yet selected.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.currentColorName","title":"<code>currentColorName() -&gt; str | None</code>","text":"<p>Returns the name of the currently selected QColor or black if None.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.invalidColorPolicy","title":"<code>invalidColorPolicy() -&gt; InvalidColorPolicy</code>","text":"<p>Returns the policy for handling invalid colors.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.itemColor","title":"<code>itemColor(index: int) -&gt; QColor | None</code>","text":"<p>Returns the color of the item at the given index.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.setCurrentColor","title":"<code>setCurrentColor(color: Any) -&gt; None</code>","text":"<p>Adds the color to the QComboBox and selects it.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.setInvalidColorPolicy","title":"<code>setInvalidColorPolicy(policy: InvalidColorPolicy | int | Literal['Raise', 'Ignore', 'Warn']) -&gt; None</code>","text":"<p>Sets the policy for handling invalid colors.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.setUserColorsAllowed","title":"<code>setUserColorsAllowed(allow: bool) -&gt; None</code>","text":"<p>Sets whether the user can add custom colors.</p>"},{"location":"widgets/qcolorcombobox/#superqt.QColorComboBox.userColorsAllowed","title":"<code>userColorsAllowed() -&gt; bool</code>","text":"<p>Returns whether the user can add custom colors.</p>"},{"location":"widgets/qcolormap/","title":"QColormapComboBox","text":"<p><code>QComboBox</code> variant to select from a specific set of colormaps.</p> <p>requires cmap</p> <p>This widget uses the cmap library to provide colormaps.  You can install it with:</p> <pre><code># use the `cmap` extra to include colormap support\npip install superqt[cmap]\n</code></pre>"},{"location":"widgets/qcolormap/#colormaplike-objects","title":"ColorMapLike objects","text":"<p>Colormaps may be specified in a variety of ways, such as by name (string), an iterable of a color/color-like objects, or as a <code>cmap.Colormap</code> instance. See cmap documentation for details on all ColormapLike types</p>"},{"location":"widgets/qcolormap/#example","title":"Example","text":"<pre><code>from cmap import Colormap\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QColormapComboBox\n\napp = QApplication([])\n\ncmap_combo = QColormapComboBox()\n# see note above about colormap-like objects\n# as names from the cmap catalog\ncmap_combo.addColormaps([\"viridis\", \"plasma\", \"magma\", \"gray\"])\n# as a sequence of colors, linearly interpolated\ncmap_combo.addColormap((\"#0f0\", \"slateblue\", \"#F3A003A0\"))\n# as a `cmap.Colormap` instance with custom name:\ncmap_combo.addColormap(Colormap((\"green\", \"white\", \"orange\"), name=\"MyMap\"))\n\ncmap_combo.show()\napp.exec()\n</code></pre>"},{"location":"widgets/qcolormap/#style-customization","title":"Style Customization","text":"<p>Note that both the LineEdit and the dropdown can be styled to have the colormap on the left, or fill the entire width of the widget.</p> <p>To make the CombBox label colormap fill the entire width of the widget:</p> <pre><code>from superqt.cmap import QColormapLineEdit\ncmap_combo.setLineEdit(QColormapLineEdit())\n</code></pre> <p>To make the CombBox dropdown colormaps fill less than the entire width of the widget:</p> <pre><code>from superqt.cmap import QColormapItemDelegate\ndelegate = QColormapItemDelegate(fractional_colormap_width=0.33)\ncmap_combo.setItemDelegate(delegate)\n</code></pre>"},{"location":"widgets/qcolormap/#qt-class","title":"Qt Class","text":"<p><code>QComboBox</code></p>"},{"location":"widgets/qcolormap/#signals","title":"Signals","text":""},{"location":"widgets/qcolormap/#currentcolormapchanged","title":"<code>currentColormapChanged</code>","text":""},{"location":"widgets/qcolormap/#methods","title":"Methods","text":"<p>A drop down menu for selecting colors.</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget.</p> <code>None</code> <code>allow_user_colormaps</code> <code>bool</code> <p>Whether the user can add custom colormaps by clicking the \"Add Colormap...\" item. Default is False. Can also be set with <code>setUserAdditionsAllowed</code>.</p> <code>False</code> <code>add_colormap_text</code> <code>str</code> <p>The text to display for the \"Add Colormap...\" item. Default is \"Add Colormap...\".</p> <code>'Add Colormap...'</code>"},{"location":"widgets/qcolormap/#superqt.QColormapComboBox.addColormap","title":"<code>addColormap(cmap: ColorStopsLike) -&gt; None</code>","text":"<p>Adds the colormap to the QComboBox.</p>"},{"location":"widgets/qcolormap/#superqt.QColormapComboBox.addColormaps","title":"<code>addColormaps(colors: Sequence[Any]) -&gt; None</code>","text":"<p>Adds colors to the QComboBox.</p>"},{"location":"widgets/qcolormap/#superqt.QColormapComboBox.currentColormap","title":"<code>currentColormap() -&gt; Colormap | None</code>","text":"<p>Returns the currently selected Colormap or None if not yet selected.</p>"},{"location":"widgets/qcolormap/#superqt.QColormapComboBox.itemColormap","title":"<code>itemColormap(index: int) -&gt; Colormap | None</code>","text":"<p>Returns the color of the item at the given index.</p>"},{"location":"widgets/qcolormap/#superqt.QColormapComboBox.setCurrentColormap","title":"<code>setCurrentColormap(color: Any) -&gt; None</code>","text":"<p>Adds the color to the QComboBox and selects it.</p>"},{"location":"widgets/qcolormap/#superqt.QColormapComboBox.setUserAdditionsAllowed","title":"<code>setUserAdditionsAllowed(allow: bool) -&gt; None</code>","text":"<p>Sets whether the user can add custom colors.</p> <p>If enabled, an \"Add Colormap...\" item will be added to the end of the list. When clicked, a dialog will be shown to allow the user to select a colormap from the cmap catalog.</p>"},{"location":"widgets/qcolormap/#superqt.QColormapComboBox.userAdditionsAllowed","title":"<code>userAdditionsAllowed() -&gt; bool</code>","text":"<p>Returns whether the user can add custom colors.</p>"},{"location":"widgets/qdoublerangeslider/","title":"QDoubleRangeSlider","text":"<p>Float variant of <code>QRangeSlider</code>. (see that page for more details).</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QDoubleRangeSlider\n\napp = QApplication([])\n\nslider = QDoubleRangeSlider(Qt.Orientation.Horizontal)\nslider.setRange(0, 1)\nslider.setValue((0.2, 0.8))\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qdoublerangeslider/#qt-class","title":"Qt Class","text":"<p><code>QSlider</code></p>"},{"location":"widgets/qdoublerangeslider/#methods","title":"Methods","text":""},{"location":"widgets/qdoubleslider/","title":"QDoubleSlider","text":"<p><code>QSlider</code> variant that accepts floating point values.</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QDoubleSlider\n\napp = QApplication([])\n\nslider = QDoubleSlider(Qt.Orientation.Horizontal)\nslider.setRange(0, 1)\nslider.setValue(0.5)\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qdoubleslider/#qt-class","title":"Qt Class","text":"<p><code>QSlider</code></p>"},{"location":"widgets/qdoubleslider/#methods","title":"Methods","text":""},{"location":"widgets/qelidinglabel/","title":"QElidingLabel","text":"<p><code>QLabel</code> variant that will elide text (i.e. add an ellipsis) if it is too long to fit in the available space.</p> <pre><code>from qtpy.QtWidgets import QApplication\n\nfrom superqt import QElidingLabel\n\napp = QApplication([])\n\nwidget = QElidingLabel(\n    \"a skj skjfskfj sdlf sdfl sdlfk jsdf sdlkf jdsf dslfksdl sdlfk sdf sdl \"\n    \"fjsdlf kjsdlfk laskdfsal as lsdfjdsl kfjdslf asfd dslkjfldskf sdlkfj\"\n)\nwidget.setWordWrap(True)\nwidget.resize(300, 20)\nwidget.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qelidinglabel/#qt-class","title":"Qt Class","text":"<p><code>QLabel</code></p>"},{"location":"widgets/qelidinglabel/#methods","title":"Methods","text":"<p>A QLabel variant that will elide text (could add '\u2026') to fit width.</p> <p>QElidingLabel() QElidingLabel(parent: Optional[QWidget], f: Qt.WindowFlags = ...) QElidingLabel(text: str, parent: Optional[QWidget] = None, f: Qt.WindowFlags = ...)</p> <p>For a multiline eliding label, use <code>setWordWrap(True)</code>.  In this case, text will wrap to fit the width, and only the last line will be elided. When <code>wordWrap()</code> is True, <code>sizeHint()</code> will return the size required to fit the full text.</p>"},{"location":"widgets/qelidinglabel/#superqt.QElidingLabel.setElideMode","title":"<code>setElideMode(mode: Qt.TextElideMode) -&gt; None</code>","text":"<p>Set the elide mode to a Qt.TextElideMode.</p>"},{"location":"widgets/qelidinglabel/#superqt.QElidingLabel.setEllipsesWidth","title":"<code>setEllipsesWidth(width: int) -&gt; None</code>","text":"<p>A width value to take into account ellipses width when eliding text.</p> <p>The value is deducted from the widget width when computing the elided version of the text.</p>"},{"location":"widgets/qenumcombobox/","title":"QEnumComboBox","text":"<p><code>QEnumComboBox</code> is a variant of <code>QComboBox</code> that populates the items in the combobox based on a python <code>Enum</code> class.  In addition to all the methods provided by <code>QComboBox</code>, this subclass adds the methods <code>enumClass</code>/<code>setEnumClass</code> to get/set the current <code>Enum</code> class represented by the combobox, and <code>currentEnum</code>/<code>setCurrentEnum</code> to get/set the current <code>Enum</code> member in the combobox. There is also a new signal <code>currentEnumChanged(enum)</code> analogous to <code>currentIndexChanged</code> and <code>currentTextChanged</code>.</p> <p>Method like <code>insertItem</code> and <code>addItem</code> are blocked and try of its usage will end with <code>RuntimeError</code></p> <pre><code>from enum import Enum\n\nfrom qtpy.QtWidgets import QApplication\nfrom superqt import QEnumComboBox\n\n\nclass SampleEnum(Enum):\n    first = 1\n    second = 2\n    third = 3\n\napp = QApplication([])\n\ncombo = QEnumComboBox()\ncombo.setEnumClass(SampleEnum)\ncombo.show()\n\napp.exec_()\n</code></pre> <p></p> <p>Another option is to use optional <code>enum_class</code> argument of constructor and change</p> <pre><code># option A:\ncombo = QEnumComboBox()\ncombo.setEnumClass(SampleEnum)\n# option B:\ncombo = QEnumComboBox(enum_class=SampleEnum)\n</code></pre>"},{"location":"widgets/qenumcombobox/#allow-none","title":"Allow <code>None</code>","text":"<p><code>QEnumComboBox</code> also allows using <code>Optional</code> type annotation:</p> <pre><code>from enum import Enum\n\nfrom superqt import QEnumComboBox\n\nclass SampleEnum(Enum):\n    first = 1\n    second = 2\n    third = 3\n\n# as usual:\n# you must create a QApplication before create a widget.\n\ncombo = QEnumComboBox()\ncombo.setEnumClass(SampleEnum, allow_none=True)\n</code></pre> <p>In this case there is added option <code>----</code> and the <code>currentEnum()</code> method will return <code>None</code> when it is selected.</p>"},{"location":"widgets/qenumcombobox/#qt-class","title":"Qt Class","text":"<p><code>QComboBox</code></p>"},{"location":"widgets/qenumcombobox/#signals","title":"Signals","text":""},{"location":"widgets/qenumcombobox/#currentenumchanged","title":"<code>currentEnumChanged</code>","text":""},{"location":"widgets/qenumcombobox/#methods","title":"Methods","text":"<p>ComboBox presenting options from a python Enum.</p> <p>If the Enum class does not implement <code>__str__</code> then a human readable name is created from the name of the enum member, replacing underscores with spaces.</p>"},{"location":"widgets/qenumcombobox/#superqt.QEnumComboBox.currentEnum","title":"<code>currentEnum() -&gt; Optional[EnumType]</code>","text":"<p>Current value as Enum member.</p>"},{"location":"widgets/qenumcombobox/#superqt.QEnumComboBox.enumClass","title":"<code>enumClass() -&gt; Optional[EnumMeta]</code>","text":"<p>Return current Enum class.</p>"},{"location":"widgets/qenumcombobox/#superqt.QEnumComboBox.isOptional","title":"<code>isOptional() -&gt; bool</code>","text":"<p>Return if current enum is with optional annotation.</p>"},{"location":"widgets/qenumcombobox/#superqt.QEnumComboBox.setCurrentEnum","title":"<code>setCurrentEnum(value: Optional[EnumType]) -&gt; None</code>","text":"<p>Set value with Enum.</p>"},{"location":"widgets/qenumcombobox/#superqt.QEnumComboBox.setEnumClass","title":"<code>setEnumClass(enum: Optional[EnumMeta], allow_none=False)</code>","text":"<p>Set enum class from which members value should be selected.</p>"},{"location":"widgets/qflowlayout/","title":"QFlowLayout","text":"<p>QLayout that rearranges items based on parent width.</p> <pre><code>from qtpy.QtWidgets import QApplication, QPushButton, QWidget\n\nfrom superqt import QFlowLayout\n\napp = QApplication([])\n\nwdg = QWidget()\n\nlayout = QFlowLayout(wdg)\nlayout.addWidget(QPushButton(\"Short\"))\nlayout.addWidget(QPushButton(\"Longer\"))\nlayout.addWidget(QPushButton(\"Different text\"))\nlayout.addWidget(QPushButton(\"More text\"))\nlayout.addWidget(QPushButton(\"Even longer button text\"))\n\nwdg.setWindowTitle(\"Flow Layout\")\nwdg.show()\n\napp.exec()\n</code></pre> <p></p>"},{"location":"widgets/qflowlayout/#qt-class","title":"Qt Class","text":"<p><code>QLayout</code></p>"},{"location":"widgets/qflowlayout/#methods","title":"Methods","text":"<p>Layout that handles different window sizes.</p> <p>The widget placement changes depending on the width of the application window.</p> <p>Code translated from C++ at: https://code.qt.io/cgit/qt/qtbase.git/tree/examples/widgets/layouts/flowlayout</p> <p>described at: https://doc.qt.io/qt-6/qtwidgets-layouts-flowlayout-example.html</p> <p>See also: https://doc.qt.io/qt-6/layout.html</p> <p>Parameters:</p> Name Type Description Default <code>parent</code> <code>QWidget</code> <p>The parent widget, by default None</p> <code>None</code>"},{"location":"widgets/qflowlayout/#superqt.QFlowLayout.horizontalSpacing","title":"<code>horizontalSpacing() -&gt; int</code>","text":"<p>Return the horizontal spacing.</p>"},{"location":"widgets/qflowlayout/#superqt.QFlowLayout.setHorizontalSpacing","title":"<code>setHorizontalSpacing(space: int | None) -&gt; None</code>","text":"<p>Set the horizontal spacing.</p> <p>If None or -1, the spacing is set to the default value based on the style of the parent widget.</p>"},{"location":"widgets/qflowlayout/#superqt.QFlowLayout.setVerticalSpacing","title":"<code>setVerticalSpacing(space: int | None) -&gt; None</code>","text":"<p>Set the vertical spacing.</p> <p>If None or -1, the spacing is set to the default value based on the style of the parent widget.</p>"},{"location":"widgets/qflowlayout/#superqt.QFlowLayout.verticalSpacing","title":"<code>verticalSpacing() -&gt; int</code>","text":"<p>Return the vertical spacing.</p>"},{"location":"widgets/qlabeleddoublerangeslider/","title":"QLabeledDoubleRangeSlider","text":"<p>Labeled Float variant of <code>QRangeSlider</code>. (see that page for more details).</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QLabeledDoubleRangeSlider\n\napp = QApplication([])\n\nslider = QLabeledDoubleRangeSlider(Qt.Orientation.Horizontal)\nslider.setRange(0, 1)\nslider.setValue((0.2, 0.8))\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qlabeleddoublerangeslider/#qt-class","title":"Qt Class","text":"<p><code>QAbstractSlider</code></p>"},{"location":"widgets/qlabeleddoublerangeslider/#enums","title":"Enums","text":""},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangesliderlabelposition","title":"<code>QLabeledDoubleRangeSlider.LabelPosition</code>","text":"<ul> <li> <p><code>NoLabel</code></p> </li> <li> <p><code>LabelsAbove</code></p> </li> <li> <p><code>LabelsBelow</code></p> </li> <li> <p><code>LabelsOnHandle</code></p> </li> </ul>"},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangeslideredgelabelmode","title":"<code>QLabeledDoubleRangeSlider.EdgeLabelMode</code>","text":"<ul> <li> <p><code>LabelIsRange</code></p> </li> <li> <p><code>LabelIsValue</code></p> </li> </ul>"},{"location":"widgets/qlabeleddoublerangeslider/#methods","title":"Methods","text":""},{"location":"widgets/qlabeleddoublerangeslider/#superqt.QLabeledDoubleRangeSlider.barColor","title":"<code>barColor = Property(QtGui.QBrush, _getBarColor, _setBarColor)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The color of the bar between the first and last handle.</p>"},{"location":"widgets/qlabeleddoublerangeslider/#superqt.QLabeledDoubleRangeSlider.decimals","title":"<code>decimals() -&gt; int</code>","text":""},{"location":"widgets/qlabeleddoublerangeslider/#superqt.QLabeledDoubleRangeSlider.setDecimals","title":"<code>setDecimals(prec: int) -&gt; None</code>","text":""},{"location":"widgets/qlabeleddoubleslider/","title":"QLabeledDoubleSlider","text":"<p><code>QDoubleSlider</code> variant that shows an editable (SpinBox) label next to the slider.</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QLabeledDoubleSlider\n\napp = QApplication([])\n\nslider = QLabeledDoubleSlider(Qt.Orientation.Horizontal)\nslider.setRange(0, 2.5)\nslider.setValue(1.3)\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qlabeleddoubleslider/#qt-class","title":"Qt Class","text":"<p><code>QAbstractSlider</code></p>"},{"location":"widgets/qlabeleddoubleslider/#enums","title":"Enums","text":""},{"location":"widgets/qlabeleddoubleslider/#qlabeleddoubleslideredgelabelmode","title":"<code>QLabeledDoubleSlider.EdgeLabelMode</code>","text":"<ul> <li> <p><code>LabelIsRange</code></p> </li> <li> <p><code>LabelIsValue</code></p> </li> </ul>"},{"location":"widgets/qlabeleddoubleslider/#methods","title":"Methods","text":""},{"location":"widgets/qlabeleddoubleslider/#superqt.QLabeledDoubleSlider.decimals","title":"<code>decimals() -&gt; int</code>","text":""},{"location":"widgets/qlabeleddoubleslider/#superqt.QLabeledDoubleSlider.setDecimals","title":"<code>setDecimals(prec: int) -&gt; None</code>","text":""},{"location":"widgets/qlabeledrangeslider/","title":"QLabeledRangeSlider","text":"<p>Labeled variant of <code>QRangeSlider</code>. (see that page for more details).</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QLabeledRangeSlider\n\napp = QApplication([])\n\nslider = QLabeledRangeSlider(Qt.Orientation.Horizontal)\nslider.setValue((20, 80))\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qlabeledrangeslider/#qt-class","title":"Qt Class","text":"<p><code>QAbstractSlider</code></p>"},{"location":"widgets/qlabeledrangeslider/#signals","title":"Signals","text":""},{"location":"widgets/qlabeledrangeslider/#editingfinished","title":"<code>editingFinished</code>","text":""},{"location":"widgets/qlabeledrangeslider/#enums","title":"Enums","text":""},{"location":"widgets/qlabeledrangeslider/#qlabeledrangesliderlabelposition","title":"<code>QLabeledRangeSlider.LabelPosition</code>","text":"<ul> <li> <p><code>NoLabel</code></p> </li> <li> <p><code>LabelsAbove</code></p> </li> <li> <p><code>LabelsBelow</code></p> </li> <li> <p><code>LabelsOnHandle</code></p> </li> </ul>"},{"location":"widgets/qlabeledrangeslider/#qlabeledrangeslideredgelabelmode","title":"<code>QLabeledRangeSlider.EdgeLabelMode</code>","text":"<ul> <li> <p><code>LabelIsRange</code></p> </li> <li> <p><code>LabelIsValue</code></p> </li> </ul>"},{"location":"widgets/qlabeledrangeslider/#methods","title":"Methods","text":"<p>If you find that you need to fine tune the position of the handle labels:</p> <ul> <li><code>QLabeledRangeSlider.label_shift_x</code>: adjust horizontal label position</li> <li><code>QLabeledRangeSlider.label_shift_y</code>: adjust vertical label position</li> </ul>"},{"location":"widgets/qlabeledrangeslider/#superqt.QLabeledRangeSlider.barColor","title":"<code>barColor = Property(QtGui.QBrush, _getBarColor, _setBarColor)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The color of the bar between the first and last handle.</p>"},{"location":"widgets/qlabeledrangeslider/#superqt.QLabeledRangeSlider.edgeLabelMode","title":"<code>edgeLabelMode() -&gt; EdgeLabelMode</code>","text":"<p>Return current <code>EdgeLabelMode</code>.</p>"},{"location":"widgets/qlabeledrangeslider/#superqt.QLabeledRangeSlider.handleLabelPosition","title":"<code>handleLabelPosition() -&gt; LabelPosition</code>","text":"<p>Return where/whether labels are shown adjacent to slider handles.</p>"},{"location":"widgets/qlabeledrangeslider/#superqt.QLabeledRangeSlider.setEdgeLabelMode","title":"<code>setEdgeLabelMode(opt: EdgeLabelMode) -&gt; None</code>","text":"<p>Set <code>EdgeLabelMode</code>, controls what is shown at the min/max labels.</p>"},{"location":"widgets/qlabeledrangeslider/#superqt.QLabeledRangeSlider.setHandleLabelPosition","title":"<code>setHandleLabelPosition(opt: LabelPosition) -&gt; None</code>","text":"<p>Set where/whether labels are shown adjacent to slider handles.</p>"},{"location":"widgets/qlabeledslider/","title":"QLabeledSlider","text":"<p><code>QSlider</code> variant that shows an editable (SpinBox) label next to the slider.</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QLabeledSlider\n\napp = QApplication([])\n\nslider = QLabeledSlider(Qt.Orientation.Horizontal)\nslider.setValue(42)\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qlabeledslider/#qt-class","title":"Qt Class","text":"<p><code>QAbstractSlider</code></p>"},{"location":"widgets/qlabeledslider/#signals","title":"Signals","text":""},{"location":"widgets/qlabeledslider/#editingfinished","title":"<code>editingFinished</code>","text":""},{"location":"widgets/qlabeledslider/#enums","title":"Enums","text":""},{"location":"widgets/qlabeledslider/#qlabeledslideredgelabelmode","title":"<code>QLabeledSlider.EdgeLabelMode</code>","text":"<ul> <li> <p><code>LabelIsRange</code></p> </li> <li> <p><code>LabelIsValue</code></p> </li> </ul>"},{"location":"widgets/qlabeledslider/#methods","title":"Methods","text":""},{"location":"widgets/qlabeledslider/#superqt.QLabeledSlider.edgeLabelMode","title":"<code>edgeLabelMode() -&gt; EdgeLabelMode</code>","text":"<p>Return current <code>EdgeLabelMode</code>.</p>"},{"location":"widgets/qlabeledslider/#superqt.QLabeledSlider.setEdgeLabelMode","title":"<code>setEdgeLabelMode(opt: EdgeLabelMode) -&gt; None</code>","text":"<p>Set the <code>EdgeLabelMode</code>.</p> <p>Parameters:</p> Name Type Description Default <code>opt</code> <code>EdgeLabelMode</code> <p>To show no label, use <code>EdgeLabelMode.NoLabel</code>. To show the value of the slider, use <code>EdgeLabelMode.LabelIsValue</code>. To show <code>value / maximum</code>, use <code>EdgeLabelMode.LabelIsValue | EdgeLabelMode.LabelIsRange</code>.</p> required"},{"location":"widgets/qlargeintspinbox/","title":"QLargeIntSpinBox","text":"<p><code>QSpinBox</code> variant that allows to enter large integers, without overflow.</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QLargeIntSpinBox\n\napp = QApplication([])\n\nslider = QLargeIntSpinBox()\nslider.setRange(0, 4.53e8)\nslider.setValue(4.53e8)\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qlargeintspinbox/#qt-class","title":"Qt Class","text":"<p><code>QAbstractSpinBox</code></p>"},{"location":"widgets/qlargeintspinbox/#signals","title":"Signals","text":""},{"location":"widgets/qlargeintspinbox/#valuechanged","title":"<code>valueChanged</code>","text":""},{"location":"widgets/qlargeintspinbox/#textchanged","title":"<code>textChanged</code>","text":""},{"location":"widgets/qlargeintspinbox/#methods","title":"Methods","text":"<p>An integer spinboxes backed by unbound python integer.</p> <p>Qt's built-in <code>QSpinBox</code> is backed by a signed 32-bit integer. This could become limiting, particularly in large dense segmentations. This class behaves like a <code>QSpinBox</code> backed by an unbound python int.</p> <p>Does not yet support \"prefix\", \"suffix\" or \"specialValue\" like QSpinBox.</p>"},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.maximum","title":"<code>maximum()</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.minimum","title":"<code>minimum()</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.setMaximum","title":"<code>setMaximum(max)</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.setMinimum","title":"<code>setMinimum(min)</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.setRange","title":"<code>setRange(minimum, maximum)</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.setSingleStep","title":"<code>setSingleStep(step)</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.setStepType","title":"<code>setStepType(stepType: QAbstractSpinBox.StepType) -&gt; None</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.setValue","title":"<code>setValue(value)</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.singleStep","title":"<code>singleStep()</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.stepType","title":"<code>stepType() -&gt; QAbstractSpinBox.StepType</code>","text":""},{"location":"widgets/qlargeintspinbox/#superqt.QLargeIntSpinBox.value","title":"<code>value()</code>","text":""},{"location":"widgets/qquantity/","title":"QQuantity","text":"<p>A widget that allows the user to edit a quantity (a magnitude associated with a unit).</p> <p>Note</p> <p>This widget requires <code>pint</code>:</p> <pre><code>pip install pint\n</code></pre> <p>or</p> <pre><code>pip install superqt[quantity]\n</code></pre> <pre><code>from qtpy.QtWidgets import QApplication\n\nfrom superqt import QQuantity\n\napp = QApplication([])\nw = QQuantity(\"1m\")\nw.show()\n\napp.exec()\n</code></pre> <p></p>"},{"location":"widgets/qquantity/#qt-class","title":"Qt Class","text":"<p><code>QWidget</code></p>"},{"location":"widgets/qquantity/#signals","title":"Signals","text":""},{"location":"widgets/qquantity/#unitschanged","title":"<code>unitsChanged</code>","text":""},{"location":"widgets/qquantity/#valuechanged","title":"<code>valueChanged</code>","text":""},{"location":"widgets/qquantity/#dimensionalitychanged","title":"<code>dimensionalityChanged</code>","text":""},{"location":"widgets/qquantity/#methods","title":"Methods","text":"<p>A combination QDoubleSpinBox and QComboBox for entering quantities.</p> <p>For this widget, <code>value()</code> returns a <code>pint.Quantity</code> object, while <code>setValue()</code> accepts either a number, <code>pint.Quantity</code>, a string that can be parsed by <code>pint</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, Quantity, Number]</code> <p>The initial value to display.  If a string, it will be parsed by <code>pint</code>.</p> <code>0</code> <code>units</code> <code>Union[UnitsContainer, str, Quantity]</code> <p>The units to use if <code>value</code> is a number.  If a string, it will be parsed by <code>pint</code>.  If a <code>pint.Quantity</code>, the units will be extracted from it.</p> <code>None</code> <code>ureg</code> <code>UnitRegistry</code> <p>The unit registry to use.  If not provided, the registry will be extracted from <code>value</code> if it is a <code>pint.Quantity</code>, otherwise the default registry will be used.</p> <code>None</code> <code>parent</code> <code>QWidget</code> <p>The parent widget, by default None</p> <code>None</code>"},{"location":"widgets/qquantity/#superqt.QQuantity.dimensionality","title":"<code>dimensionality() -&gt; UnitsContainer</code>","text":"<p>Return the current dimensionality (cast to <code>str</code> for nice repr).</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.isDimensionless","title":"<code>isDimensionless() -&gt; bool</code>","text":"<p>Return <code>True</code> if the current value is dimensionless.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.magnitude","title":"<code>magnitude() -&gt; Union[float, int]</code>","text":"<p>Return the magnitude of the current value.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.magnitudeSpinBox","title":"<code>magnitudeSpinBox() -&gt; QDoubleSpinBox</code>","text":"<p>Return the <code>QSpinBox</code> widget used to edit the magnitude.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.setDecimals","title":"<code>setDecimals(decimals: int) -&gt; None</code>","text":"<p>Set the number of decimals to display in the spinbox.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.setMagnitude","title":"<code>setMagnitude(magnitude: Number) -&gt; None</code>","text":"<p>Set the magnitude of the current value.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.setUnits","title":"<code>setUnits(units: Union[str, Unit, Quantity]) -&gt; None</code>","text":"<p>Set the units of the current value.</p> <p>If <code>units</code> is <code>None</code>, will convert to a dimensionless quantity. Otherwise, units must be compatible with the current dimensionality.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.setValue","title":"<code>setValue(value: Union[str, Quantity, Number], units: Optional[Union[UnitsContainer, str, Quantity]] = None) -&gt; None</code>","text":"<p>Set the current value (will cast to a pint Quantity).</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.text","title":"<code>text() -&gt; str</code>","text":""},{"location":"widgets/qquantity/#superqt.QQuantity.unitRegistry","title":"<code>unitRegistry() -&gt; UnitRegistry</code>","text":"<p>Return the pint UnitRegistry used by this widget.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.units","title":"<code>units() -&gt; Unit</code>","text":"<p>Return the current units.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.unitsComboBox","title":"<code>unitsComboBox() -&gt; QComboBox</code>","text":"<p>Return the <code>QCombBox</code> widget used to edit the units.</p>"},{"location":"widgets/qquantity/#superqt.QQuantity.value","title":"<code>value() -&gt; Quantity</code>","text":"<p>Return the current value as a <code>pint.Quantity</code>.</p>"},{"location":"widgets/qrangeslider/","title":"QRangeSlider","text":"<p>A multi-handle slider widget than can be used to select a range of values.</p> <pre><code>from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QApplication\n\nfrom superqt import QRangeSlider\n\napp = QApplication([])\n\nslider = QRangeSlider(Qt.Orientation.Horizontal)\nslider.setValue((20, 80))\nslider.show()\n\napp.exec_()\n</code></pre> <p></p> <ul> <li><code>QRangeSlider</code> inherits from <code>QSlider</code>   and attempts to match the Qt API as closely as possible</li> <li>It uses platform-specific styles (for handle, groove, &amp; ticks) but also supports   QSS style sheets.</li> <li>Supports mouse wheel events</li> <li>Supports more than 2 handles (e.g. <code>slider.setValue([0, 10, 60, 80])</code>)</li> </ul> <p>As <code>QRangeSlider</code> inherits from <code>QtWidgets.QSlider</code>, you can use all of the same methods available in the QSlider API. The major difference is that <code>value()</code> and <code>sliderPosition()</code> are reimplemented as <code>tuples</code> of <code>int</code> (where the length of the tuple is equal to the number of handles in the slider.)</p> <p>These options are in addition to the Qt QSlider API, and control the behavior of the bar between handles.</p> getter setter type default description <code>barIsVisible</code> <code>setBarIsVisible</code> <code>hideBar</code> / <code>showBar</code> <code>bool</code> <code>True</code> Whether the bar between handles is visible. <code>barMovesAllHandles</code> <code>setBarMovesAllHandles</code> <code>bool</code> <code>True</code> Whether clicking on the bar moves all handles or just the nearest <code>barIsRigid</code> <code>setBarIsRigid</code> <code>bool</code> <code>True</code> Whether bar length is constant or \"elastic\" when dragging the bar beyond min/max."},{"location":"widgets/qrangeslider/#screenshots","title":"Screenshots","text":"code that generates the images below <pre><code>import os\n\nfrom qtpy import QtCore\nfrom qtpy import QtWidgets as QtW\n\n# patch for Qt 5.15 on macos &gt;= 12\nos.environ[\"USE_MAC_SLIDER_PATCH\"] = \"1\"\n\nfrom superqt import QRangeSlider  # noqa\n\nQSS = \"\"\"\nQSlider {\n    min-height: 20px;\n}\n\nQSlider::groove:horizontal {\n    border: 0px;\n    background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #888, stop:1 #ddd);\n    height: 20px;\n    border-radius: 10px;\n}\n\nQSlider::handle {\n    background: qradialgradient(cx:0, cy:0, radius: 1.2, fx:0.35,\n                                fy:0.3, stop:0 #eef, stop:1 #002);\n    height: 20px;\n    width: 20px;\n    border-radius: 10px;\n}\n\nQSlider::sub-page:horizontal {\n    background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a);\n    border-top-left-radius: 10px;\n    border-bottom-left-radius: 10px;\n}\n\nQRangeSlider {\n    qproperty-barColor: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a);\n}\n\"\"\"\n\nHorizontal = QtCore.Qt.Orientation.Horizontal\n\n\nclass DemoWidget(QtW.QWidget):\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n        reg_hslider = QtW.QSlider(Horizontal)\n        reg_hslider.setValue(50)\n        range_hslider = QRangeSlider(Horizontal)\n        range_hslider.setValue((20, 80))\n        multi_range_hslider = QRangeSlider(Horizontal)\n        multi_range_hslider.setValue((11, 33, 66, 88))\n        multi_range_hslider.setTickPosition(QtW.QSlider.TickPosition.TicksAbove)\n\n        styled_reg_hslider = QtW.QSlider(Horizontal)\n        styled_reg_hslider.setValue(50)\n        styled_reg_hslider.setStyleSheet(QSS)\n        styled_range_hslider = QRangeSlider(Horizontal)\n        styled_range_hslider.setValue((20, 80))\n        styled_range_hslider.setStyleSheet(QSS)\n\n        reg_vslider = QtW.QSlider(QtCore.Qt.Orientation.Vertical)\n        reg_vslider.setValue(50)\n        range_vslider = QRangeSlider(QtCore.Qt.Orientation.Vertical)\n        range_vslider.setValue((22, 77))\n\n        tick_vslider = QtW.QSlider(QtCore.Qt.Orientation.Vertical)\n        tick_vslider.setValue(55)\n        tick_vslider.setTickPosition(QtW.QSlider.TicksRight)\n        range_tick_vslider = QRangeSlider(QtCore.Qt.Orientation.Vertical)\n        range_tick_vslider.setValue((22, 77))\n        range_tick_vslider.setTickPosition(QtW.QSlider.TicksLeft)\n\n        szp = QtW.QSizePolicy.Maximum\n        left = QtW.QWidget()\n        left.setLayout(QtW.QVBoxLayout())\n        left.setContentsMargins(2, 2, 2, 2)\n        label1 = QtW.QLabel(\"Regular QSlider Unstyled\")\n        label2 = QtW.QLabel(\"QRangeSliders Unstyled\")\n        label3 = QtW.QLabel(\"Styled Sliders (using same stylesheet)\")\n        label1.setSizePolicy(szp, szp)\n        label2.setSizePolicy(szp, szp)\n        label3.setSizePolicy(szp, szp)\n        left.layout().addWidget(label1)\n        left.layout().addWidget(reg_hslider)\n        left.layout().addWidget(label2)\n        left.layout().addWidget(range_hslider)\n        left.layout().addWidget(multi_range_hslider)\n        left.layout().addWidget(label3)\n        left.layout().addWidget(styled_reg_hslider)\n        left.layout().addWidget(styled_range_hslider)\n\n        right = QtW.QWidget()\n        right.setLayout(QtW.QHBoxLayout())\n        right.setContentsMargins(15, 5, 5, 0)\n        right.layout().setSpacing(30)\n        right.layout().addWidget(reg_vslider)\n        right.layout().addWidget(range_vslider)\n        right.layout().addWidget(tick_vslider)\n        right.layout().addWidget(range_tick_vslider)\n\n        self.setLayout(QtW.QHBoxLayout())\n        self.layout().addWidget(left)\n        self.layout().addWidget(right)\n        self.setGeometry(600, 300, 580, 300)\n        self.activateWindow()\n        self.show()\n\n\nif __name__ == \"__main__\":\n\n    import sys\n    from pathlib import Path\n\n    dest = Path(\"screenshots\")\n    dest.mkdir(exist_ok=True)\n\n    app = QtW.QApplication([])\n    demo = DemoWidget()\n\n    if \"-snap\" in sys.argv:\n        import platform\n\n        QtW.QApplication.processEvents()\n        demo.grab().save(str(dest / f\"demo_{platform.system().lower()}.png\"))\n    else:\n        app.exec_()\n</code></pre>"},{"location":"widgets/qrangeslider/#macos","title":"macOS","text":""},{"location":"widgets/qrangeslider/#catalina","title":"Catalina","text":""},{"location":"widgets/qrangeslider/#big-sur","title":"Big Sur","text":""},{"location":"widgets/qrangeslider/#windows","title":"Windows","text":""},{"location":"widgets/qrangeslider/#linux","title":"Linux","text":""},{"location":"widgets/qrangeslider/#qt-class","title":"Qt Class","text":"<p><code>QSlider</code></p>"},{"location":"widgets/qrangeslider/#methods","title":"Methods","text":"<p>MultiHandle Range Slider widget.</p> <p>Same API as QSlider, but <code>value</code>, <code>setValue</code>, <code>sliderPosition</code>, and <code>setSliderPosition</code> are all sequences of integers.</p> <p>The <code>valueChanged</code> and <code>sliderMoved</code> signals also both emit a tuple of integers.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.barColor","title":"<code>barColor = Property(QtGui.QBrush, _getBarColor, _setBarColor)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The color of the bar between the first and last handle.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.applyMacStylePatch","title":"<code>applyMacStylePatch() -&gt; None</code>","text":"<p>Apply a QSS patch to fix sliders on macos&gt;=12 with QT &lt; 6.</p> <p>see FAQ for more details.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.barIsRigid","title":"<code>barIsRigid() -&gt; bool</code>","text":"<p>Whether bar length is constant when dragging the bar.</p> <p>If <code>False</code>, the bar can shorten when dragged beyond min/max. Default is <code>True</code>.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.barIsVisible","title":"<code>barIsVisible() -&gt; bool</code>","text":"<p>Whether to show the bar between the first and last handle.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.barMovesAllHandles","title":"<code>barMovesAllHandles() -&gt; bool</code>","text":"<p>Whether clicking on the bar moves all handles, or just the nearest.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.hideBar","title":"<code>hideBar() -&gt; None</code>","text":"<p>Hide the bar between the first and last handle.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.setBarIsRigid","title":"<code>setBarIsRigid(val: bool = True) -&gt; None</code>","text":"<p>Whether bar length is constant when dragging the bar.</p> <p>If <code>False</code>, the bar can shorten when dragged beyond min/max. Default is <code>True</code>.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.setBarMovesAllHandles","title":"<code>setBarMovesAllHandles(val: bool = True) -&gt; None</code>","text":"<p>Whether clicking on the bar moves all handles, or just the nearest.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.setBarVisible","title":"<code>setBarVisible(val: bool = True) -&gt; None</code>","text":"<p>Whether to show the bar between the first and last handle.</p>"},{"location":"widgets/qrangeslider/#superqt.sliders._sliders._GenericRangeSlider.showBar","title":"<code>showBar() -&gt; None</code>","text":"<p>Show the bar between the first and last handle.</p>"},{"location":"widgets/qrangeslider/#type-changes","title":"Type changes","text":"<p>Note the following changes in types compared to the <code>QSlider</code> API:</p> <pre><code>value() -&gt; Tuple[int, ...]\n</code></pre> <pre><code>setValue(val: Sequence[int]) -&gt; None\n</code></pre> <pre><code># Signal\nvalueChanged(Tuple[int, ...])\n</code></pre> <pre><code>sliderPosition() -&gt; Tuple[int, ...]\n</code></pre> <pre><code>setSliderPosition(val: Sequence[int]) -&gt; None\n</code></pre> <pre><code>sliderMoved(Tuple[int, ...])\n</code></pre>"},{"location":"widgets/qsearchablecombobox/","title":"QSearchableComboBox","text":"<p><code>QSearchableComboBox</code> is a variant of <code>QComboBox</code> that allow to filter list of options by enter part of text. It could be drop in replacement for <code>QComboBox</code>.</p> <pre><code>from qtpy.QtWidgets import QApplication\n\nfrom superqt import QSearchableComboBox\n\napp = QApplication([])\n\ncombo = QSearchableComboBox()\ncombo.addItems([\"foo\", \"bar\", \"baz\", \"foobar\", \"foobaz\", \"barbaz\"])\ncombo.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qsearchablecombobox/#qt-class","title":"Qt Class","text":"<p><code>QComboBox</code></p>"},{"location":"widgets/qsearchablelistwidget/","title":"QSearchableListWidget","text":"<p><code>QSearchableListWidget</code> is a variant of <code>QListWidget</code> that add text entry above list widget that allow to filter list of available options.</p> <p>Due to implementation details, this widget it does not inherit directly from <code>QListWidget</code> but it does fully satisfy its api. The only limitation is that it cannot be used as argument of <code>QListWidgetItem</code> constructor.</p> <pre><code>from qtpy.QtWidgets import QApplication\n\nfrom superqt import QSearchableListWidget\n\napp = QApplication([])\n\nslider = QSearchableListWidget()\nslider.addItems([\"foo\", \"bar\", \"baz\", \"foobar\", \"foobaz\", \"barbaz\"])\nslider.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qsearchablelistwidget/#qt-class","title":"Qt Class","text":"<p><code>QWidget</code></p>"},{"location":"widgets/qsearchablelistwidget/#methods","title":"Methods","text":""},{"location":"widgets/qsearchablelistwidget/#superqt.QSearchableListWidget.addItem","title":"<code>addItem(*args)</code>","text":""},{"location":"widgets/qsearchablelistwidget/#superqt.QSearchableListWidget.addItems","title":"<code>addItems(*args)</code>","text":""},{"location":"widgets/qsearchablelistwidget/#superqt.QSearchableListWidget.insertItem","title":"<code>insertItem(*args)</code>","text":""},{"location":"widgets/qsearchablelistwidget/#superqt.QSearchableListWidget.insertItems","title":"<code>insertItems(*args)</code>","text":""},{"location":"widgets/qsearchablelistwidget/#superqt.QSearchableListWidget.update_visible","title":"<code>update_visible(text)</code>","text":""},{"location":"widgets/qsearchabletreewidget/","title":"QSearchableTreeWidget","text":"<p><code>QSearchableTreeWidget</code> combines a <code>QTreeWidget</code> and a <code>QLineEdit</code> for showing a mapping that can be searched by key.</p> <p>This is intended to be used with a read-only mapping and be conveniently created using <code>QSearchableTreeWidget.fromData(data)</code>. If the mapping changes, the easiest way to update this is by calling <code>setData</code>.</p> <pre><code>from qtpy.QtWidgets import QApplication\n\nfrom superqt import QSearchableTreeWidget\n\napp = QApplication([])\n\ndata = {\n    \"none\": None,\n    \"str\": \"test\",\n    \"int\": 42,\n    \"list\": [2, 3, 5],\n    \"dict\": {\n        \"float\": 0.5,\n        \"tuple\": (22, 99),\n        \"bool\": False,\n    },\n}\ntree = QSearchableTreeWidget.fromData(data)\ntree.show()\n\napp.exec_()\n</code></pre> <p></p>"},{"location":"widgets/qsearchabletreewidget/#qt-class","title":"Qt Class","text":"<p><code>QWidget</code></p>"},{"location":"widgets/qsearchabletreewidget/#methods","title":"Methods","text":"<p>A tree widget for showing a mapping that can be searched by key.</p> <p>This is intended to be used with a read-only mapping and be conveniently created using <code>QSearchableTreeWidget.fromData(data)</code>. If the mapping changes, the easiest way to update this is by calling <code>setData</code>.</p> <p>The tree can be searched by entering a regular expression pattern into the <code>filter</code> line edit. An item is only shown if its, any of its ancestors', or any of its descendants' keys or values match this pattern. The regular expression follows the conventions described by the Qt docs: https://doc.qt.io/qt-5/qregularexpression.html#details</p> <p>Attributes:</p> Name Type Description <code>tree</code> <code>QTreeWidget</code> <p>Shows the mapping as a tree of items.</p> <code>filter</code> <code>QLineEdit</code> <p>Used to filter items in the tree by matching their key against a regular expression.</p>"},{"location":"widgets/qsearchabletreewidget/#superqt.QSearchableTreeWidget.fromData","title":"<code>fromData(data: Mapping, *, parent: QWidget = None) -&gt; QSearchableTreeWidget</code>  <code>classmethod</code>","text":"<p>Make a searchable tree widget from a mapping.</p>"},{"location":"widgets/qsearchabletreewidget/#superqt.QSearchableTreeWidget.setData","title":"<code>setData(data: Mapping) -&gt; None</code>","text":"<p>Update the mapping data shown by the tree.</p>"}]}