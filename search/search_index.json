{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"superqt \"missing\" widgets and components for PyQt/PySide This repository aims to provide high-quality community-contributed Qt widgets and components for PyQt & PySide that are not provided in the native QtWidgets module. Components are tested on: macOS, Windows, & Linux Python 3.7 and above PyQt5 (5.11 and above) & PyQt6 PySide2 (5.11 and above) & PySide6 Installation pip install superqt conda install -c conda-forge superqt Usage See the Widgets and Utilities pages for features offered by superqt.","title":"superqt"},{"location":"#superqt","text":"","title":"superqt"},{"location":"#missing-widgets-and-components-for-pyqtpyside","text":"This repository aims to provide high-quality community-contributed Qt widgets and components for PyQt & PySide that are not provided in the native QtWidgets module. Components are tested on: macOS, Windows, & Linux Python 3.7 and above PyQt5 (5.11 and above) & PyQt6 PySide2 (5.11 and above) & PySide6","title":"\"missing\" widgets and components for PyQt/PySide"},{"location":"#installation","text":"pip install superqt conda install -c conda-forge superqt","title":"Installation"},{"location":"#usage","text":"See the Widgets and Utilities pages for features offered by superqt.","title":"Usage"},{"location":"faq/","text":"FAQ Sliders not dragging properly on MacOS 12+ Details On MacOS Monterey, with Qt5, there is a bug that causes all sliders (including native Qt sliders) to not respond properly to drag events. See: https://bugreports.qt.io/browse/QTBUG-98093 https://github.com/napari/superqt/issues/74 Superqt includes a workaround for this issue, but it is not perfect, and it requires using a custom stylesheet (which may interfere with your own styles). Note that you may not see this issue if you're already using custom stylesheets. To opt in to the workaround, do any of the following: set the environment variable USE_MAC_SLIDER_PATCH=1 before importing superqt (note: this is safe to use even if you're targeting more than just MacOS 12, it will only be applied when needed) call the applyMacStylePatch() method on any of the superqt slider subclasses (note, this will override your slider styles) apply the stylesheet manually: from superqt.sliders import MONTEREY_SLIDER_STYLES_FIX slider . setStyleSheet ( MONTEREY_SLIDER_STYLES_FIX )","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#sliders-not-dragging-properly-on-macos-12","text":"Details On MacOS Monterey, with Qt5, there is a bug that causes all sliders (including native Qt sliders) to not respond properly to drag events. See: https://bugreports.qt.io/browse/QTBUG-98093 https://github.com/napari/superqt/issues/74 Superqt includes a workaround for this issue, but it is not perfect, and it requires using a custom stylesheet (which may interfere with your own styles). Note that you may not see this issue if you're already using custom stylesheets. To opt in to the workaround, do any of the following: set the environment variable USE_MAC_SLIDER_PATCH=1 before importing superqt (note: this is safe to use even if you're targeting more than just MacOS 12, it will only be applied when needed) call the applyMacStylePatch() method on any of the superqt slider subclasses (note, this will override your slider styles) apply the stylesheet manually: from superqt.sliders import MONTEREY_SLIDER_STYLES_FIX slider . setStyleSheet ( MONTEREY_SLIDER_STYLES_FIX )","title":"Sliders not dragging properly on MacOS 12+"},{"location":"utilities/","text":"Utilities Object Description QMessageHandler A context manager to intercept messages from Qt. ensure_main_thread Decorator that ensures a function is called in the main QApplication thread. ensure_object_thread Decorator that ensures a QObject method is called in the object's thread. CodeSyntaxHighlight A QSyntaxHighlighter for code syntax highlighting.","title":"Utilities"},{"location":"utilities/#utilities","text":"Object Description QMessageHandler A context manager to intercept messages from Qt. ensure_main_thread Decorator that ensures a function is called in the main QApplication thread. ensure_object_thread Decorator that ensures a QObject method is called in the object's thread. CodeSyntaxHighlight A QSyntaxHighlighter for code syntax highlighting.","title":"Utilities"},{"location":"utilities/code_syntax_highlight/","text":"CodeSyntaxHighlight A code highlighter subclass of QSyntaxHighlighter that can be used to highlight code in a QTextEdit. Code lexer and available styles are from pygments python library List of available languages are available here . List of available styles are available here . Example from qtpy.QtGui import QColor , QPalette from qtpy.QtWidgets import QApplication , QTextEdit from superqt.utils import CodeSyntaxHighlight app = QApplication ([]) text_area = QTextEdit () highlight = CodeSyntaxHighlight ( text_area . document (), \"python\" , \"monokai\" ) palette = text_area . palette () palette . setColor ( QPalette . Base , QColor ( highlight . background_color )) text_area . setPalette ( palette ) text_area . setText ( \"\"\"from argparse import ArgumentParser def main(): parser = ArgumentParser() parser.add_argument(\"name\", help=\"Your name\") args = parser.parse_args() print(f\"Hello {args.name}\") if __name__ == \"__main__\": main() \"\"\" ) text_area . show () text_area . resize ( 400 , 200 ) app . exec_ () Qt Class QSyntaxHighlighter Methods background_color () property","title":"CodeSyntaxHighlight"},{"location":"utilities/code_syntax_highlight/#codesyntaxhighlight","text":"A code highlighter subclass of QSyntaxHighlighter that can be used to highlight code in a QTextEdit. Code lexer and available styles are from pygments python library List of available languages are available here . List of available styles are available here .","title":"CodeSyntaxHighlight"},{"location":"utilities/code_syntax_highlight/#example","text":"from qtpy.QtGui import QColor , QPalette from qtpy.QtWidgets import QApplication , QTextEdit from superqt.utils import CodeSyntaxHighlight app = QApplication ([]) text_area = QTextEdit () highlight = CodeSyntaxHighlight ( text_area . document (), \"python\" , \"monokai\" ) palette = text_area . palette () palette . setColor ( QPalette . Base , QColor ( highlight . background_color )) text_area . setPalette ( palette ) text_area . setText ( \"\"\"from argparse import ArgumentParser def main(): parser = ArgumentParser() parser.add_argument(\"name\", help=\"Your name\") args = parser.parse_args() print(f\"Hello {args.name}\") if __name__ == \"__main__\": main() \"\"\" ) text_area . show () text_area . resize ( 400 , 200 ) app . exec_ ()","title":"Example"},{"location":"utilities/code_syntax_highlight/#qt-class","text":"QSyntaxHighlighter","title":"Qt Class"},{"location":"utilities/code_syntax_highlight/#methods","text":"","title":"Methods"},{"location":"utilities/code_syntax_highlight/#superqt.utils._code_syntax_highlight.CodeSyntaxHighlight.background_color","text":"","title":"background_color()"},{"location":"utilities/qmessagehandler/","text":"QMessageHandler superqt.utils.QMessageHandler A context manager to intercept messages from Qt. Parameters: Name Type Description Default logger logging . Logger , optional If provided, intercepted messages will be logged with logger at the corresponding python log level, by default None None Attributes: Name Type Description records list of tuple Captured messages. This is a 3-tuple of: (log_level: int, message: str, context: dict) Examples: >>> handler = QMessageHandler () >>> handler . install () # now all Qt output will be available at mh.records >>> with QMessageHandler () as handler : # temporarily install ... ... >>> logger = logging . getLogger ( __name__ ) >>> with QMessageHandler ( logger ): # re-reoute Qt messages to a python logger. ... ... __enter__ () Enter a context with this handler installed install () Install this handler (override the current QtMessageHandler). uninstall () Uninstall this handler, restoring the previous handler.","title":"QMessageHandler"},{"location":"utilities/qmessagehandler/#qmessagehandler","text":"","title":"QMessageHandler"},{"location":"utilities/qmessagehandler/#superqt.utils.QMessageHandler","text":"A context manager to intercept messages from Qt. Parameters: Name Type Description Default logger logging . Logger , optional If provided, intercepted messages will be logged with logger at the corresponding python log level, by default None None Attributes: Name Type Description records list of tuple Captured messages. This is a 3-tuple of: (log_level: int, message: str, context: dict) Examples: >>> handler = QMessageHandler () >>> handler . install () # now all Qt output will be available at mh.records >>> with QMessageHandler () as handler : # temporarily install ... ... >>> logger = logging . getLogger ( __name__ ) >>> with QMessageHandler ( logger ): # re-reoute Qt messages to a python logger. ... ...","title":"QMessageHandler"},{"location":"utilities/qmessagehandler/#superqt.utils._message_handler.QMessageHandler.__enter__","text":"Enter a context with this handler installed","title":"__enter__()"},{"location":"utilities/qmessagehandler/#superqt.utils._message_handler.QMessageHandler.install","text":"Install this handler (override the current QtMessageHandler).","title":"install()"},{"location":"utilities/qmessagehandler/#superqt.utils._message_handler.QMessageHandler.uninstall","text":"Uninstall this handler, restoring the previous handler.","title":"uninstall()"},{"location":"utilities/thread_decorators/","text":"Threading decorators superqt provides two decorators that help to ensure that given function is running in the desired thread: ensure_main_thread ensure_main_thread ensures that the decorated function/method runs in the main thread ensure_object_thread ensure_object_thread ensures that a decorated bound method of a QObject runs in the thread in which the instance lives ( see qt documentation for details ). Usage By default, functions are executed asynchronously (they return immediately with an instance of concurrent.futures.Future ). To block and wait for the result, see Synchronous mode from qtpy.QtCore import QObject from superqt import ensure_main_thread , ensure_object_thread @ensure_main_thread def sample_function (): print ( \"This function will run in main thread\" ) class SampleObject ( QObject ): def __init__ ( self ): super () . __init__ () self . _value = 1 @ensure_main_thread def sample_method1 ( self ): print ( \"This method will run in main thread\" ) @ensure_object_thread def sample_method3 ( self ): import time print ( \"sleeping\" ) time . sleep ( 1 ) print ( \"This method will run in object thread\" ) @property def value ( self ): print ( \"return value\" ) return self . _value @value . setter @ensure_object_thread def value ( self , value ): print ( \"this setter will run in object thread\" ) self . _value = value As can be seen in this example these decorators can also be used for setters. These decorators should not be used as replacement of Qt Signals but rather to interact with Qt objects from non Qt code. Synchronous mode If you'd like for the program to block and wait for the result of your function call, use the await_return=True parameter, and optionally specify a timeout. Important Using synchronous mode may significantly impact performance. from superqt import ensure_main_thread @ensure_main_thread def sample_function1 (): return 1 @ensure_main_thread ( await_return = True ) def sample_function2 (): return 2 assert sample_function1 () is None assert sample_function2 () == 2 # optionally, specify a timeout @ensure_main_thread ( await_return = True , timeout = 10000 ) def sample_function (): return 1","title":"Threading decorators"},{"location":"utilities/thread_decorators/#threading-decorators","text":"superqt provides two decorators that help to ensure that given function is running in the desired thread:","title":"Threading decorators"},{"location":"utilities/thread_decorators/#ensure_main_thread","text":"ensure_main_thread ensures that the decorated function/method runs in the main thread","title":"ensure_main_thread"},{"location":"utilities/thread_decorators/#ensure_object_thread","text":"ensure_object_thread ensures that a decorated bound method of a QObject runs in the thread in which the instance lives ( see qt documentation for details ).","title":"ensure_object_thread"},{"location":"utilities/thread_decorators/#usage","text":"By default, functions are executed asynchronously (they return immediately with an instance of concurrent.futures.Future ). To block and wait for the result, see Synchronous mode from qtpy.QtCore import QObject from superqt import ensure_main_thread , ensure_object_thread @ensure_main_thread def sample_function (): print ( \"This function will run in main thread\" ) class SampleObject ( QObject ): def __init__ ( self ): super () . __init__ () self . _value = 1 @ensure_main_thread def sample_method1 ( self ): print ( \"This method will run in main thread\" ) @ensure_object_thread def sample_method3 ( self ): import time print ( \"sleeping\" ) time . sleep ( 1 ) print ( \"This method will run in object thread\" ) @property def value ( self ): print ( \"return value\" ) return self . _value @value . setter @ensure_object_thread def value ( self , value ): print ( \"this setter will run in object thread\" ) self . _value = value As can be seen in this example these decorators can also be used for setters. These decorators should not be used as replacement of Qt Signals but rather to interact with Qt objects from non Qt code.","title":"Usage"},{"location":"utilities/thread_decorators/#synchronous-mode","text":"If you'd like for the program to block and wait for the result of your function call, use the await_return=True parameter, and optionally specify a timeout. Important Using synchronous mode may significantly impact performance. from superqt import ensure_main_thread @ensure_main_thread def sample_function1 (): return 1 @ensure_main_thread ( await_return = True ) def sample_function2 (): return 2 assert sample_function1 () is None assert sample_function2 () == 2 # optionally, specify a timeout @ensure_main_thread ( await_return = True , timeout = 10000 ) def sample_function (): return 1","title":"Synchronous mode"},{"location":"utilities/threading/","text":"Thread workers The objects in this module provide utilities for running tasks in a separate thread. In general (with the exception of new_worker_qthread ), everything here wraps Qt's QRunnable API . The highest level object is the @thread_worker decorator. It was originally written for napari , and was later extracted into superqt . You may also be interested in reading the napari documentation on this feature, which provides a more in-depth/introductory usage guide. For additional control, you can create your own FunctionWorker or GeneratorWorker objects. superqt.utils.WorkerBase Bases: QRunnable , Generic [ _R ] Base class for creating a Worker that can run in another thread. Parameters: Name Type Description Default SignalsClass type , optional A QObject subclass that contains signals, by default WorkerBaseSignals WorkerBaseSignals Attributes: Name Type Description signals WorkerBaseSignals signal emitter object. To allow identify which worker thread emitted signal. __getattr__ ( name ) Pass through attr requests to signals to simplify connection API. The goal is to enable worker.yielded.connect instead of worker.signals.yielded.connect . Because multiple inheritance of Qt classes is not well supported in PyQt, we have to use composition here (signals are provided by QObjects, and QRunnable is not a QObject). So this passthrough allows us to connect to signals on the _signals object. abort_requested () property Whether the worker has been requested to stop. await_workers ( msecs = None ) classmethod Ask all workers to quit, and wait up to msec for quit. Attempts to clean up all running workers by calling worker.quit() method. Any workers in the WorkerBase._worker_set set will have this method. By default, this function will block indefinitely, until worker threads finish. If a timeout is provided, a RuntimeError will be raised if the workers do not gracefully exit in the time requests, but the threads will NOT be killed. It is (currently) left to the user to use their OS to force-quit rogue threads. Important If the user does not put any yields in their function, and the function is super long, it will just hang... For instance, there's no graceful way to kill this thread in python: @thread_worker def ZZZzzz (): time . sleep ( 10000000 ) This is why it's always advisable to use a generator that periodically yields for long-running computations in another thread. See this stack-overflow post for a good discussion on the difficulty of killing a rogue python thread: Parameters: Name Type Description Default msecs int , optional Waits up to msecs milliseconds for all threads to exit and removes all threads from the thread pool. If msecs is None (the default), the timeout is ignored (waits for the last thread to exit). None Raises: Type Description RuntimeError If a timeout is provided and workers do not quit successfully within the time allotted. is_running () property Whether the worker has been started quit () Send a request to abort the worker. Note It is entirely up to subclasses to honor this method by checking self.abort_requested periodically in their worker.work method, and exiting if True . run () Start the worker. The end-user should never need to call this function. But it cannot be made private or renamed, since it is called by Qt. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work This is the function that actually gets called when calling QThreadPool.start(worker) . It simply wraps the work() method, and emits a few signals. Subclasses should NOT override this method (except with good reason), and instead should implement work() . start () Start this worker in a thread and add it to the global threadpool. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work work () Main method to execute the worker. The end-user should never need to call this function. But subclasses must implement this method (See GeneratorFunction.work for an example implementation). Minimally, it should check self.abort_requested periodically and exit if True. Examples: class MyWorker ( WorkerBase ): def work ( self ): i = 0 while True : if self . abort_requested : self . aborted . emit () break i += 1 if i > max_iters : break time . sleep ( 0.5 ) superqt.utils.FunctionWorker Bases: WorkerBase [ _R ] QRunnable with signals that wraps a simple long-running function. Note FunctionWorker does not provide a way to stop a very long-running function (e.g. time.sleep(10000) ). So whenever possible, it is better to implement your long running function as a generator that yields periodically, and use the GeneratorWorker instead. Parameters: Name Type Description Default func Callable A function to call in another thread required *args will be passed to the function () **kwargs will be passed to the function {} Raises: Type Description TypeError If func is a generator function and not a regular function. superqt.utils.GeneratorWorker Bases: WorkerBase , Generic [ _Y , _S , _R ] QRunnable with signals that wraps a long-running generator. Provides a convenient way to run a generator function in another thread, while allowing 2-way communication between threads, using plain-python generator syntax in the original function. Parameters: Name Type Description Default func callable The function being run in another thread. May be a generator function. required SignalsClass type , optional A QObject subclass that contains signals, by default GeneratorWorkerSignals GeneratorWorkerSignals *args Will be passed to func on instantiation () **kwargs Will be passed to func on instantiation {} is_paused () property Whether the worker is currently paused. pause () Request to pause the worker. resume () Send a request to resume the worker. send ( value ) Send a value into the function (if a generator was used). toggle_pause () Request to pause the worker if playing or resume if paused. work () Core event loop that calls the original function. Enters a continual loop, yielding and returning from the original function. Checks for various events (quit, pause, resume, etc...). (To clarify: we are creating a rudimentary event loop here because there IS NO Qt event loop running in the other thread to hook into) Convenience functions superqt . utils . thread_worker ( function = None , start_thread = None , connect = None , worker_class = None , ignore_errors = False ) Decorator that runs a function in a separate thread when called. When called, the decorated function returns a WorkerBase . See create_worker for additional keyword arguments that can be used when calling the function. The returned worker will have these signals: started : emitted when the work is started finished : emitted when the work is finished returned : emitted with return value errored : emitted with error object on Exception It will also have a worker.start() method that can be used to start execution of the function in another thread. (useful if you need to connect callbacks to signals prior to execution) If the decorated function is a generator, the returned worker will also provide these signals: yielded : emitted with yielded values paused : emitted when a running job has successfully paused resumed : emitted when a paused job has successfully resumed aborted : emitted when a running job is successfully aborted And these methods: quit : ask the thread to quit toggle_paused : toggle the running state of the thread. send : send a value into the generator. (This requires that your decorator function uses the value = yield syntax) Parameters: Name Type Description Default function callable Function to call in another thread. For communication between threads may be a generator function. None start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None connect Dict [ str , Union [ Callable , Sequence ]] A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None worker_class Type [ WorkerBase ] The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False Returns: Type Description callable function that creates a worker, puts it in a new thread and returns the worker instance. Examples: @thread_worker def long_function ( start , end ): # do work, periodically yielding i = start while i <= end : time . sleep ( 0.1 ) yield i # do teardown return 'anything' # call the function to start running in another thread. worker = long_function () # connect signals here if desired... or they may be added using the # `connect` argument in the `@thread_worker` decorator... in which # case the worker will start immediately when long_function() is called worker . start () superqt . utils . create_worker ( func , * args , _start_thread = None , _connect = None , _worker_class = None , _ignore_errors = False , ** kwargs ) Convenience function to start a function in another thread. By default, uses FunctionWorker for functions and GeneratorWorker for generators, but a custom WorkerBase subclass may be provided. If so, it must be a subclass of WorkerBase , which defines a standard set of signals and a run method. Parameters: Name Type Description Default func Callable The function to call in another thread. required _start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None _connect Dict [ str , Union [ Callable , Sequence ]], optional A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None _worker_class type of The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None _ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False *args will be passed to func () **kwargs will be passed to func {} Returns: Name Type Description worker WorkerBase An instantiated worker. If _start_thread was False , the worker will have a .start() method that can be used to start the thread. Raises: Type Description TypeError If a worker_class is provided that is not a subclass of WorkerBase. TypeError If _connect is provided and is not a dict of {str: callable} Examples: def long_function ( duration ): import time time . sleep ( duration ) worker = create_worker ( long_function , 10 ) superqt . utils . new_worker_qthread ( Worker , * args , _start_thread = False , _connect = None , ** kwargs ) This is a convenience function to start a worker in a QThread . In most cases, the thread_worker decorator is sufficient and preferable. But this allows the user to completely customize the Worker object. However, they must then maintain control over the thread and clean up appropriately. It follows the pattern described here and in the qt thread docs see also: https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/ A QThread object is not a thread! It should be thought of as a class to manage a thread, not as the actual code or object that runs in that thread. The QThread object is created on the main thread and lives there. Worker objects which derive from QObject are the things that actually do the work. They can be moved to a QThread as is done here. Mostly ignorable detail While the signals/slots syntax of the worker looks very similar to standard \"single-threaded\" signals & slots, note that inter-thread signals and slots (automatically) use an event-based QueuedConnection, while intra-thread signals use a DirectConnection. See Signals and Slots Across Threads Parameters: Name Type Description Default Worker QObject QObject type that implements a work() method. The Worker should also emit a finished signal when the work is done. required _start_thread bool If True, thread will be started immediately, otherwise, thread must be manually started with thread.start(). False _connect dict Optional dictionary of {signal: function} to connect to the new worker. for instance: _connect = {'incremented': myfunc} will result in: worker.incremented.connect(myfunc) None *args will be passed to the Worker class on instantiation. () **kwargs will be passed to the Worker class on instantiation. {} Returns: Name Type Description worker WorkerBase The created worker. thread QThread The thread on which the worker is running. Examples: Create some QObject that has a long-running work method: class Worker ( QObject ): finished = Signal () increment = Signal ( int ) def __init__ ( self , argument ): super () . __init__ () self . argument = argument @Slot () def work ( self ): # some long running task... import time for i in range ( 10 ): time . sleep ( 1 ) self . increment . emit ( i ) self . finished . emit () worker , thread = new_worker_qthread ( Worker , 'argument' , _start_thread = True , _connect = { 'increment' : print }, )","title":"Thread workers"},{"location":"utilities/threading/#thread-workers","text":"The objects in this module provide utilities for running tasks in a separate thread. In general (with the exception of new_worker_qthread ), everything here wraps Qt's QRunnable API . The highest level object is the @thread_worker decorator. It was originally written for napari , and was later extracted into superqt . You may also be interested in reading the napari documentation on this feature, which provides a more in-depth/introductory usage guide. For additional control, you can create your own FunctionWorker or GeneratorWorker objects.","title":"Thread workers"},{"location":"utilities/threading/#superqt.utils.WorkerBase","text":"Bases: QRunnable , Generic [ _R ] Base class for creating a Worker that can run in another thread. Parameters: Name Type Description Default SignalsClass type , optional A QObject subclass that contains signals, by default WorkerBaseSignals WorkerBaseSignals Attributes: Name Type Description signals WorkerBaseSignals signal emitter object. To allow identify which worker thread emitted signal.","title":"WorkerBase"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.__getattr__","text":"Pass through attr requests to signals to simplify connection API. The goal is to enable worker.yielded.connect instead of worker.signals.yielded.connect . Because multiple inheritance of Qt classes is not well supported in PyQt, we have to use composition here (signals are provided by QObjects, and QRunnable is not a QObject). So this passthrough allows us to connect to signals on the _signals object.","title":"__getattr__()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.abort_requested","text":"Whether the worker has been requested to stop.","title":"abort_requested()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.await_workers","text":"Ask all workers to quit, and wait up to msec for quit. Attempts to clean up all running workers by calling worker.quit() method. Any workers in the WorkerBase._worker_set set will have this method. By default, this function will block indefinitely, until worker threads finish. If a timeout is provided, a RuntimeError will be raised if the workers do not gracefully exit in the time requests, but the threads will NOT be killed. It is (currently) left to the user to use their OS to force-quit rogue threads. Important If the user does not put any yields in their function, and the function is super long, it will just hang... For instance, there's no graceful way to kill this thread in python: @thread_worker def ZZZzzz (): time . sleep ( 10000000 ) This is why it's always advisable to use a generator that periodically yields for long-running computations in another thread. See this stack-overflow post for a good discussion on the difficulty of killing a rogue python thread: Parameters: Name Type Description Default msecs int , optional Waits up to msecs milliseconds for all threads to exit and removes all threads from the thread pool. If msecs is None (the default), the timeout is ignored (waits for the last thread to exit). None Raises: Type Description RuntimeError If a timeout is provided and workers do not quit successfully within the time allotted.","title":"await_workers()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.is_running","text":"Whether the worker has been started","title":"is_running()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.quit","text":"Send a request to abort the worker. Note It is entirely up to subclasses to honor this method by checking self.abort_requested periodically in their worker.work method, and exiting if True .","title":"quit()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.run","text":"Start the worker. The end-user should never need to call this function. But it cannot be made private or renamed, since it is called by Qt. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work This is the function that actually gets called when calling QThreadPool.start(worker) . It simply wraps the work() method, and emits a few signals. Subclasses should NOT override this method (except with good reason), and instead should implement work() .","title":"run()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.start","text":"Start this worker in a thread and add it to the global threadpool. The order of method calls when starting a worker is: calls QThreadPool.globalInstance().start(worker) | triggered by the QThreadPool.start() method | | called by worker.run | | | V V V worker.start -> worker.run -> worker.work","title":"start()"},{"location":"utilities/threading/#superqt.utils._qthreading.WorkerBase.work","text":"Main method to execute the worker. The end-user should never need to call this function. But subclasses must implement this method (See GeneratorFunction.work for an example implementation). Minimally, it should check self.abort_requested periodically and exit if True. Examples: class MyWorker ( WorkerBase ): def work ( self ): i = 0 while True : if self . abort_requested : self . aborted . emit () break i += 1 if i > max_iters : break time . sleep ( 0.5 )","title":"work()"},{"location":"utilities/threading/#superqt.utils.FunctionWorker","text":"Bases: WorkerBase [ _R ] QRunnable with signals that wraps a simple long-running function. Note FunctionWorker does not provide a way to stop a very long-running function (e.g. time.sleep(10000) ). So whenever possible, it is better to implement your long running function as a generator that yields periodically, and use the GeneratorWorker instead. Parameters: Name Type Description Default func Callable A function to call in another thread required *args will be passed to the function () **kwargs will be passed to the function {} Raises: Type Description TypeError If func is a generator function and not a regular function.","title":"FunctionWorker"},{"location":"utilities/threading/#superqt.utils.GeneratorWorker","text":"Bases: WorkerBase , Generic [ _Y , _S , _R ] QRunnable with signals that wraps a long-running generator. Provides a convenient way to run a generator function in another thread, while allowing 2-way communication between threads, using plain-python generator syntax in the original function. Parameters: Name Type Description Default func callable The function being run in another thread. May be a generator function. required SignalsClass type , optional A QObject subclass that contains signals, by default GeneratorWorkerSignals GeneratorWorkerSignals *args Will be passed to func on instantiation () **kwargs Will be passed to func on instantiation {}","title":"GeneratorWorker"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.is_paused","text":"Whether the worker is currently paused.","title":"is_paused()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.pause","text":"Request to pause the worker.","title":"pause()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.resume","text":"Send a request to resume the worker.","title":"resume()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.send","text":"Send a value into the function (if a generator was used).","title":"send()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.toggle_pause","text":"Request to pause the worker if playing or resume if paused.","title":"toggle_pause()"},{"location":"utilities/threading/#superqt.utils._qthreading.GeneratorWorker.work","text":"Core event loop that calls the original function. Enters a continual loop, yielding and returning from the original function. Checks for various events (quit, pause, resume, etc...). (To clarify: we are creating a rudimentary event loop here because there IS NO Qt event loop running in the other thread to hook into)","title":"work()"},{"location":"utilities/threading/#convenience-functions","text":"","title":"Convenience functions"},{"location":"utilities/threading/#superqt.utils.thread_worker","text":"Decorator that runs a function in a separate thread when called. When called, the decorated function returns a WorkerBase . See create_worker for additional keyword arguments that can be used when calling the function. The returned worker will have these signals: started : emitted when the work is started finished : emitted when the work is finished returned : emitted with return value errored : emitted with error object on Exception It will also have a worker.start() method that can be used to start execution of the function in another thread. (useful if you need to connect callbacks to signals prior to execution) If the decorated function is a generator, the returned worker will also provide these signals: yielded : emitted with yielded values paused : emitted when a running job has successfully paused resumed : emitted when a paused job has successfully resumed aborted : emitted when a running job is successfully aborted And these methods: quit : ask the thread to quit toggle_paused : toggle the running state of the thread. send : send a value into the generator. (This requires that your decorator function uses the value = yield syntax) Parameters: Name Type Description Default function callable Function to call in another thread. For communication between threads may be a generator function. None start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None connect Dict [ str , Union [ Callable , Sequence ]] A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None worker_class Type [ WorkerBase ] The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False Returns: Type Description callable function that creates a worker, puts it in a new thread and returns the worker instance. Examples: @thread_worker def long_function ( start , end ): # do work, periodically yielding i = start while i <= end : time . sleep ( 0.1 ) yield i # do teardown return 'anything' # call the function to start running in another thread. worker = long_function () # connect signals here if desired... or they may be added using the # `connect` argument in the `@thread_worker` decorator... in which # case the worker will start immediately when long_function() is called worker . start ()","title":"thread_worker()"},{"location":"utilities/threading/#superqt.utils.create_worker","text":"Convenience function to start a function in another thread. By default, uses FunctionWorker for functions and GeneratorWorker for generators, but a custom WorkerBase subclass may be provided. If so, it must be a subclass of WorkerBase , which defines a standard set of signals and a run method. Parameters: Name Type Description Default func Callable The function to call in another thread. required _start_thread bool Whether to immediaetly start the thread. If False, the returned worker must be manually started with worker.start() . by default it will be False if the _connect argument is None , otherwise True . None _connect Dict [ str , Union [ Callable , Sequence ]], optional A mapping of \"signal_name\" -> callable or list of callable : callback functions to connect to the various signals offered by the worker class. by default None None _worker_class type of The WorkerBase to instantiate, by default FunctionWorker will be used if func is a regular function, and GeneratorWorker will be used if it is a generator. None _ignore_errors bool If False (the default), errors raised in the other thread will be reraised in the main thread (makes debugging significantly easier). False *args will be passed to func () **kwargs will be passed to func {} Returns: Name Type Description worker WorkerBase An instantiated worker. If _start_thread was False , the worker will have a .start() method that can be used to start the thread. Raises: Type Description TypeError If a worker_class is provided that is not a subclass of WorkerBase. TypeError If _connect is provided and is not a dict of {str: callable} Examples: def long_function ( duration ): import time time . sleep ( duration ) worker = create_worker ( long_function , 10 )","title":"create_worker()"},{"location":"utilities/threading/#superqt.utils.new_worker_qthread","text":"This is a convenience function to start a worker in a QThread . In most cases, the thread_worker decorator is sufficient and preferable. But this allows the user to completely customize the Worker object. However, they must then maintain control over the thread and clean up appropriately. It follows the pattern described here and in the qt thread docs see also: https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/ A QThread object is not a thread! It should be thought of as a class to manage a thread, not as the actual code or object that runs in that thread. The QThread object is created on the main thread and lives there. Worker objects which derive from QObject are the things that actually do the work. They can be moved to a QThread as is done here. Mostly ignorable detail While the signals/slots syntax of the worker looks very similar to standard \"single-threaded\" signals & slots, note that inter-thread signals and slots (automatically) use an event-based QueuedConnection, while intra-thread signals use a DirectConnection. See Signals and Slots Across Threads Parameters: Name Type Description Default Worker QObject QObject type that implements a work() method. The Worker should also emit a finished signal when the work is done. required _start_thread bool If True, thread will be started immediately, otherwise, thread must be manually started with thread.start(). False _connect dict Optional dictionary of {signal: function} to connect to the new worker. for instance: _connect = {'incremented': myfunc} will result in: worker.incremented.connect(myfunc) None *args will be passed to the Worker class on instantiation. () **kwargs will be passed to the Worker class on instantiation. {} Returns: Name Type Description worker WorkerBase The created worker. thread QThread The thread on which the worker is running. Examples: Create some QObject that has a long-running work method: class Worker ( QObject ): finished = Signal () increment = Signal ( int ) def __init__ ( self , argument ): super () . __init__ () self . argument = argument @Slot () def work ( self ): # some long running task... import time for i in range ( 10 ): time . sleep ( 1 ) self . increment . emit ( i ) self . finished . emit () worker , thread = new_worker_qthread ( Worker , 'argument' , _start_thread = True , _connect = { 'increment' : print }, )","title":"new_worker_qthread()"},{"location":"utilities/throttling/","text":"Throttling & Debouncing These utilities allow you to throttle or debounce a function. This is useful when you have a function that is called multiple times in a short period of time, and you want to make sure it is only \"actually\" called once (or at least no more than a certain frequency). For background on throttling and debouncing, see: https://blog.openreplay.com/forever-functional-debouncing-and-throttling-for-performance https://css-tricks.com/debouncing-throttling-explained-examples/ superqt . utils . qdebounced ( func = None , timeout = 100 , leading = False , timer_type = Qt . TimerType . PreciseTimer ) Creates a debounced function that delays invoking func . func will not be invoked until timeout ms have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default False False timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer superqt . utils . qthrottled ( func = None , timeout = 100 , leading = True , timer_type = Qt . TimerType . PreciseTimer ) Creates a throttled function that invokes func at most once per timeout. The throttled function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the throttled function. Subsequent calls to the throttled function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default True True timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer superqt.utils.QSignalDebouncer Bases: GenericSignalThrottler A Signal Debouncer. This object's triggered signal will not be emitted until self.timeout() milliseconds have elapsed since the last time triggered was emitted. superqt.utils.QSignalThrottler Bases: GenericSignalThrottler A Signal Throttler. This object's triggered signal will emit at most once per timeout (set with setTimeout()). superqt.utils._throttler.GenericSignalThrottler Bases: QObject cancel () Cancel any pending emissions. emissionPolicy () Return the emission policy (trailing or leading). flush () Force emission of any pending emissions. kind () Return the kind of throttler (throttler or debouncer). setTimeout ( timeout ) Set timeout in milliseconds setTimerType ( timerType ) Set current Qt.TimerType. throttle () Emit triggered if not running, then start timer. timeout () Return current timeout in milliseconds. timerType () Return current Qt.TimerType .","title":"Throttling & Debouncing"},{"location":"utilities/throttling/#throttling-debouncing","text":"These utilities allow you to throttle or debounce a function. This is useful when you have a function that is called multiple times in a short period of time, and you want to make sure it is only \"actually\" called once (or at least no more than a certain frequency). For background on throttling and debouncing, see: https://blog.openreplay.com/forever-functional-debouncing-and-throttling-for-performance https://css-tricks.com/debouncing-throttling-explained-examples/","title":"Throttling &amp; Debouncing"},{"location":"utilities/throttling/#superqt.utils.qdebounced","text":"Creates a debounced function that delays invoking func . func will not be invoked until timeout ms have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default False False timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer","title":"qdebounced()"},{"location":"utilities/throttling/#superqt.utils.qthrottled","text":"Creates a throttled function that invokes func at most once per timeout. The throttled function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the throttled function. Subsequent calls to the throttled function return the result of the last func invocation. This decorator may be used with or without parameters. Parameters: Name Type Description Default func Callable A function to throttle None timeout int Timeout in milliseconds to wait before allowing another call, by default 100 100 leading bool Whether to invoke the function on the leading edge of the wait timer, by default True True timer_type Qt . TimerType The timer type. by default Qt.TimerType.PreciseTimer One of: - Qt.PreciseTimer : Precise timers try to keep millisecond accuracy - Qt.CoarseTimer : Coarse timers try to keep accuracy within 5% of the desired interval - Qt.VeryCoarseTimer : Very coarse timers only keep full second accuracy Qt.TimerType.PreciseTimer","title":"qthrottled()"},{"location":"utilities/throttling/#superqt.utils.QSignalDebouncer","text":"Bases: GenericSignalThrottler A Signal Debouncer. This object's triggered signal will not be emitted until self.timeout() milliseconds have elapsed since the last time triggered was emitted.","title":"QSignalDebouncer"},{"location":"utilities/throttling/#superqt.utils.QSignalThrottler","text":"Bases: GenericSignalThrottler A Signal Throttler. This object's triggered signal will emit at most once per timeout (set with setTimeout()).","title":"QSignalThrottler"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler","text":"Bases: QObject","title":"GenericSignalThrottler"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.cancel","text":"Cancel any pending emissions.","title":"cancel()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.emissionPolicy","text":"Return the emission policy (trailing or leading).","title":"emissionPolicy()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.flush","text":"Force emission of any pending emissions.","title":"flush()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.kind","text":"Return the kind of throttler (throttler or debouncer).","title":"kind()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.setTimeout","text":"Set timeout in milliseconds","title":"setTimeout()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.setTimerType","text":"Set current Qt.TimerType.","title":"setTimerType()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.throttle","text":"Emit triggered if not running, then start timer.","title":"throttle()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.timeout","text":"Return current timeout in milliseconds.","title":"timeout()"},{"location":"utilities/throttling/#superqt.utils._throttler.GenericSignalThrottler.timerType","text":"Return current Qt.TimerType .","title":"timerType()"},{"location":"widgets/","text":"Widgets The following are QWidget subclasses: Sliders and Numerical Inputs Widget Description QDoubleRangeSlider Multi-handle slider for float values QDoubleSlider Slider for float values QLabeledDoubleRangeSlider QDoubleRangeSlider variant with editable labels for each handle QLabeledDoubleSlider QSlider for float values with editable QSpinBox with the current value QLabeledRangeSlider QRangeSlider variant, with editable labels for each handle QLabeledSlider QSlider with editable QSpinBox that shows the current value QLargeIntSpinBox QSpinbox that accepts arbitrarily large integers QRangeSlider Multi-handle slider Labels and categorical inputs Widget Description QElidingLabel A QLabel variant that will elide text (add \u2026 ) to fit width. QEnumComboBox QComboBox that populates the combobox from a python Enum QSearchableComboBox QComboBox variant that filters available options based on text input QSearchableListWidget QListWidget variant with search field that filters available options Frames and containers Widget Description QCollapsible A collapsible widget to hide and unhide child widgets.","title":"Widgets"},{"location":"widgets/#widgets","text":"The following are QWidget subclasses:","title":"Widgets"},{"location":"widgets/#sliders-and-numerical-inputs","text":"Widget Description QDoubleRangeSlider Multi-handle slider for float values QDoubleSlider Slider for float values QLabeledDoubleRangeSlider QDoubleRangeSlider variant with editable labels for each handle QLabeledDoubleSlider QSlider for float values with editable QSpinBox with the current value QLabeledRangeSlider QRangeSlider variant, with editable labels for each handle QLabeledSlider QSlider with editable QSpinBox that shows the current value QLargeIntSpinBox QSpinbox that accepts arbitrarily large integers QRangeSlider Multi-handle slider","title":"Sliders and Numerical Inputs"},{"location":"widgets/#labels-and-categorical-inputs","text":"Widget Description QElidingLabel A QLabel variant that will elide text (add \u2026 ) to fit width. QEnumComboBox QComboBox that populates the combobox from a python Enum QSearchableComboBox QComboBox variant that filters available options based on text input QSearchableListWidget QListWidget variant with search field that filters available options","title":"Labels and categorical inputs"},{"location":"widgets/#frames-and-containers","text":"Widget Description QCollapsible A collapsible widget to hide and unhide child widgets.","title":"Frames and containers"},{"location":"widgets/qcollapsible/","text":"QCollapsible Collapsible QFrame that can be expanded or collapsed by clicking on the header. from qtpy.QtWidgets import QApplication , QLabel , QPushButton from superqt import QCollapsible app = QApplication ([]) collapsible = QCollapsible ( \"Advanced analysis\" ) collapsible . addWidget ( QLabel ( \"This is the inside of the collapsible frame\" )) for i in range ( 10 ): collapsible . addWidget ( QPushButton ( f \"Content button { i + 1 } \" )) collapsible . expand ( animate = False ) collapsible . show () app . exec_ () Qt Class QFrame Methods A collapsible widget to hide and unhide child widgets. Based on https://stackoverflow.com/a/68141638 addWidget ( widget : QWidget ) Add a widget to the central content widget's layout. collapse ( animate : bool = True ) Collapse (hide) the collapsible section content () -> QWidget Return the current content widget. expand ( animate : bool = True ) Expand (show) the collapsible section isExpanded () -> bool Return whether the collapsible section is visible locked () -> bool Return True if collapse/expand is disabled removeWidget ( widget : QWidget ) Remove widget from the central content widget's layout. setContent ( content : QWidget ) Replace central widget (the widget that gets expanded/collapsed). setDuration ( msecs : int ) Set duration of the collapse/expand animation. setEasingCurve ( easing : QEasingCurve ) Set the easing curve for the collapse/expand animation setLocked ( locked : bool = True ) Set whether collapse/expand is disabled setText ( text : str ) Set the text of the toggle button. text () -> str Return the text of the toggle button.","title":"QCollapsible"},{"location":"widgets/qcollapsible/#qcollapsible","text":"Collapsible QFrame that can be expanded or collapsed by clicking on the header. from qtpy.QtWidgets import QApplication , QLabel , QPushButton from superqt import QCollapsible app = QApplication ([]) collapsible = QCollapsible ( \"Advanced analysis\" ) collapsible . addWidget ( QLabel ( \"This is the inside of the collapsible frame\" )) for i in range ( 10 ): collapsible . addWidget ( QPushButton ( f \"Content button { i + 1 } \" )) collapsible . expand ( animate = False ) collapsible . show () app . exec_ ()","title":"QCollapsible"},{"location":"widgets/qcollapsible/#qt-class","text":"QFrame","title":"Qt Class"},{"location":"widgets/qcollapsible/#methods","text":"A collapsible widget to hide and unhide child widgets. Based on https://stackoverflow.com/a/68141638","title":"Methods"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.addWidget","text":"Add a widget to the central content widget's layout.","title":"addWidget()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.collapse","text":"Collapse (hide) the collapsible section","title":"collapse()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.content","text":"Return the current content widget.","title":"content()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.expand","text":"Expand (show) the collapsible section","title":"expand()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.isExpanded","text":"Return whether the collapsible section is visible","title":"isExpanded()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.locked","text":"Return True if collapse/expand is disabled","title":"locked()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.removeWidget","text":"Remove widget from the central content widget's layout.","title":"removeWidget()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setContent","text":"Replace central widget (the widget that gets expanded/collapsed).","title":"setContent()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setDuration","text":"Set duration of the collapse/expand animation.","title":"setDuration()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setEasingCurve","text":"Set the easing curve for the collapse/expand animation","title":"setEasingCurve()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setLocked","text":"Set whether collapse/expand is disabled","title":"setLocked()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.setText","text":"Set the text of the toggle button.","title":"setText()"},{"location":"widgets/qcollapsible/#superqt.collapsible._collapsible.QCollapsible.text","text":"Return the text of the toggle button.","title":"text()"},{"location":"widgets/qdoublerangeslider/","text":"QDoubleRangeSlider Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleRangeSlider app = QApplication ([]) slider = QDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ () Qt Class QSlider Methods","title":"QDoubleRangeSlider"},{"location":"widgets/qdoublerangeslider/#qdoublerangeslider","text":"Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleRangeSlider app = QApplication ([]) slider = QDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ ()","title":"QDoubleRangeSlider"},{"location":"widgets/qdoublerangeslider/#qt-class","text":"QSlider","title":"Qt Class"},{"location":"widgets/qdoublerangeslider/#methods","text":"","title":"Methods"},{"location":"widgets/qdoubleslider/","text":"QDoubleSlider QSlider variant that accepts floating point values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleSlider app = QApplication ([]) slider = QDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue ( 0.5 ) slider . show () app . exec_ () Qt Class QSlider Methods","title":"QDoubleSlider"},{"location":"widgets/qdoubleslider/#qdoubleslider","text":"QSlider variant that accepts floating point values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QDoubleSlider app = QApplication ([]) slider = QDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue ( 0.5 ) slider . show () app . exec_ ()","title":"QDoubleSlider"},{"location":"widgets/qdoubleslider/#qt-class","text":"QSlider","title":"Qt Class"},{"location":"widgets/qdoubleslider/#methods","text":"","title":"Methods"},{"location":"widgets/qelidinglabel/","text":"QElidingLabel QLabel variant that will elide text (i.e. add an ellipsis) if it is too long to fit in the available space. from qtpy.QtWidgets import QApplication from superqt import QElidingLabel app = QApplication ([]) widget = QElidingLabel ( \"a skj skjfskfj sdlf sdfl sdlfk jsdf sdlkf jdsf dslfksdl sdlfk sdf sdl \" \"fjsdlf kjsdlfk laskdfsal as lsdfjdsl kfjdslf asfd dslkjfldskf sdlkfj\" ) widget . setWordWrap ( True ) widget . resize ( 300 , 20 ) widget . show () app . exec_ () Qt Class QLabel Methods A QLabel variant that will elide text (add '\u2026') to fit width. QElidingLabel() QElidingLabel(parent: Optional[QWidget], f: Qt.WindowFlags = ...) QElidingLabel(text: str, parent: Optional[QWidget] = None, f: Qt.WindowFlags = ...) For a multiline eliding label, use setWordWrap(True) . In this case, text will wrap to fit the width, and only the last line will be elided. When wordWrap() is True, sizeHint() will return the size required to fit the full text. elideMode () -> Qt . TextElideMode The current Qt.TextElideMode. setElideMode ( mode : Qt . TextElideMode ) Set the elide mode to a Qt.TextElideMode. wrapText ( text , width , font = None ) -> List [ str ] staticmethod Returns text , split as it would be wrapped for width , given font . Static method.","title":"QElidingLabel"},{"location":"widgets/qelidinglabel/#qelidinglabel","text":"QLabel variant that will elide text (i.e. add an ellipsis) if it is too long to fit in the available space. from qtpy.QtWidgets import QApplication from superqt import QElidingLabel app = QApplication ([]) widget = QElidingLabel ( \"a skj skjfskfj sdlf sdfl sdlfk jsdf sdlkf jdsf dslfksdl sdlfk sdf sdl \" \"fjsdlf kjsdlfk laskdfsal as lsdfjdsl kfjdslf asfd dslkjfldskf sdlkfj\" ) widget . setWordWrap ( True ) widget . resize ( 300 , 20 ) widget . show () app . exec_ ()","title":"QElidingLabel"},{"location":"widgets/qelidinglabel/#qt-class","text":"QLabel","title":"Qt Class"},{"location":"widgets/qelidinglabel/#methods","text":"A QLabel variant that will elide text (add '\u2026') to fit width. QElidingLabel() QElidingLabel(parent: Optional[QWidget], f: Qt.WindowFlags = ...) QElidingLabel(text: str, parent: Optional[QWidget] = None, f: Qt.WindowFlags = ...) For a multiline eliding label, use setWordWrap(True) . In this case, text will wrap to fit the width, and only the last line will be elided. When wordWrap() is True, sizeHint() will return the size required to fit the full text.","title":"Methods"},{"location":"widgets/qelidinglabel/#superqt._eliding_label.QElidingLabel.elideMode","text":"The current Qt.TextElideMode.","title":"elideMode()"},{"location":"widgets/qelidinglabel/#superqt._eliding_label.QElidingLabel.setElideMode","text":"Set the elide mode to a Qt.TextElideMode.","title":"setElideMode()"},{"location":"widgets/qelidinglabel/#superqt._eliding_label.QElidingLabel.wrapText","text":"Returns text , split as it would be wrapped for width , given font . Static method.","title":"wrapText()"},{"location":"widgets/qenumcombobox/","text":"QEnumComboBox QEnumComboBox is a variant of QComboBox that populates the items in the combobox based on a python Enum class. In addition to all the methods provided by QComboBox , this subclass adds the methods enumClass / setEnumClass to get/set the current Enum class represented by the combobox, and currentEnum / setCurrentEnum to get/set the current Enum member in the combobox. There is also a new signal currentEnumChanged(enum) analogous to currentIndexChanged and currentTextChanged . Method like insertItem and addItem are blocked and try of its usage will end with RuntimeError from enum import Enum from qtpy.QtWidgets import QApplication from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 app = QApplication ([]) combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) combo . show () app . exec_ () Another option is to use optional enum_class argument of constructor and change # option A: combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) # option B: combo = QEnumComboBox ( enum_class = SampleEnum ) Allow None QEnumComboBox also allows using Optional type annotation: from enum import Enum from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 # as usual: # you must create a QApplication before create a widget. combo = QEnumComboBox () combo . setEnumClass ( SampleEnum , allow_none = True ) In this case there is added option ---- and the currentEnum() method will return None when it is selected. Qt Class QComboBox Signals currentEnumChanged Methods ComboBox presenting options from a python Enum. If the Enum class does not implement __str__ then a human readable name is created from the name of the enum member, replacing underscores with spaces. currentEnum () -> Optional [ EnumType ] current value as Enum member enumClass () -> Optional [ EnumMeta ] return current Enum class isOptional () -> bool return if current enum is with optional annotation setCurrentEnum ( value : Optional [ EnumType ]) -> None Set value with Enum. setEnumClass ( enum : Optional [ EnumMeta ], allow_none = False ) Set enum class from which members value should be selected","title":"QEnumComboBox"},{"location":"widgets/qenumcombobox/#qenumcombobox","text":"QEnumComboBox is a variant of QComboBox that populates the items in the combobox based on a python Enum class. In addition to all the methods provided by QComboBox , this subclass adds the methods enumClass / setEnumClass to get/set the current Enum class represented by the combobox, and currentEnum / setCurrentEnum to get/set the current Enum member in the combobox. There is also a new signal currentEnumChanged(enum) analogous to currentIndexChanged and currentTextChanged . Method like insertItem and addItem are blocked and try of its usage will end with RuntimeError from enum import Enum from qtpy.QtWidgets import QApplication from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 app = QApplication ([]) combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) combo . show () app . exec_ () Another option is to use optional enum_class argument of constructor and change # option A: combo = QEnumComboBox () combo . setEnumClass ( SampleEnum ) # option B: combo = QEnumComboBox ( enum_class = SampleEnum )","title":"QEnumComboBox"},{"location":"widgets/qenumcombobox/#allow-none","text":"QEnumComboBox also allows using Optional type annotation: from enum import Enum from superqt import QEnumComboBox class SampleEnum ( Enum ): first = 1 second = 2 third = 3 # as usual: # you must create a QApplication before create a widget. combo = QEnumComboBox () combo . setEnumClass ( SampleEnum , allow_none = True ) In this case there is added option ---- and the currentEnum() method will return None when it is selected.","title":"Allow None"},{"location":"widgets/qenumcombobox/#qt-class","text":"QComboBox","title":"Qt Class"},{"location":"widgets/qenumcombobox/#signals","text":"","title":"Signals"},{"location":"widgets/qenumcombobox/#currentenumchanged","text":"","title":"currentEnumChanged"},{"location":"widgets/qenumcombobox/#methods","text":"ComboBox presenting options from a python Enum. If the Enum class does not implement __str__ then a human readable name is created from the name of the enum member, replacing underscores with spaces.","title":"Methods"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.currentEnum","text":"current value as Enum member","title":"currentEnum()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.enumClass","text":"return current Enum class","title":"enumClass()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.isOptional","text":"return if current enum is with optional annotation","title":"isOptional()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.setCurrentEnum","text":"Set value with Enum.","title":"setCurrentEnum()"},{"location":"widgets/qenumcombobox/#superqt.combobox._enum_combobox.QEnumComboBox.setEnumClass","text":"Set enum class from which members value should be selected","title":"setEnumClass()"},{"location":"widgets/qlabeleddoublerangeslider/","text":"QLabeledDoubleRangeSlider Labeled Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleRangeSlider app = QApplication ([]) slider = QLabeledDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ () Qt Class QAbstractSlider Enums QLabeledDoubleRangeSlider.LabelPosition NoLabel LabelsAbove LabelsBelow QLabeledDoubleRangeSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods decimals () -> int setDecimals ( prec : int )","title":"QLabeledDoubleRangeSlider"},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangeslider","text":"Labeled Float variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleRangeSlider app = QApplication ([]) slider = QLabeledDoubleRangeSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 1 ) slider . setValue (( 0.2 , 0.8 )) slider . show () app . exec_ ()","title":"QLabeledDoubleRangeSlider"},{"location":"widgets/qlabeleddoublerangeslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeleddoublerangeslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangesliderlabelposition","text":"NoLabel LabelsAbove LabelsBelow","title":"QLabeledDoubleRangeSlider.LabelPosition"},{"location":"widgets/qlabeleddoublerangeslider/#qlabeleddoublerangeslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledDoubleRangeSlider.EdgeLabelMode"},{"location":"widgets/qlabeleddoublerangeslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeleddoublerangeslider/#superqt.sliders._labeled.QLabeledDoubleRangeSlider.decimals","text":"","title":"decimals()"},{"location":"widgets/qlabeleddoublerangeslider/#superqt.sliders._labeled.QLabeledDoubleRangeSlider.setDecimals","text":"","title":"setDecimals()"},{"location":"widgets/qlabeleddoubleslider/","text":"QLabeledDoubleSlider QDoubleSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleSlider app = QApplication ([]) slider = QLabeledDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 2.5 ) slider . setValue ( 1.3 ) slider . show () app . exec_ () Qt Class QAbstractSlider Enums QLabeledDoubleSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods decimals () -> int setDecimals ( prec : int )","title":"QLabeledDoubleSlider"},{"location":"widgets/qlabeleddoubleslider/#qlabeleddoubleslider","text":"QDoubleSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledDoubleSlider app = QApplication ([]) slider = QLabeledDoubleSlider ( Qt . Orientation . Horizontal ) slider . setRange ( 0 , 2.5 ) slider . setValue ( 1.3 ) slider . show () app . exec_ ()","title":"QLabeledDoubleSlider"},{"location":"widgets/qlabeleddoubleslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeleddoubleslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeleddoubleslider/#qlabeleddoubleslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledDoubleSlider.EdgeLabelMode"},{"location":"widgets/qlabeleddoubleslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeleddoubleslider/#superqt.sliders._labeled.QLabeledDoubleSlider.decimals","text":"","title":"decimals()"},{"location":"widgets/qlabeleddoubleslider/#superqt.sliders._labeled.QLabeledDoubleSlider.setDecimals","text":"","title":"setDecimals()"},{"location":"widgets/qlabeledrangeslider/","text":"QLabeledRangeSlider Labeled variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledRangeSlider app = QApplication ([]) slider = QLabeledRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ () Qt Class QAbstractSlider Signals editingFinished Enums QLabeledRangeSlider.LabelPosition NoLabel LabelsAbove LabelsBelow QLabeledRangeSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods edgeLabelMode () -> EdgeLabelMode Return current EdgeLabelMode . handleLabelPosition () -> LabelPosition Return where/whether labels are shown adjacent to slider handles. setEdgeLabelMode ( opt : EdgeLabelMode ) Set EdgeLabelMode , controls what is shown at the min/max labels. setHandleLabelPosition ( opt : LabelPosition ) -> LabelPosition Set where/whether labels are shown adjacent to slider handles. If you find that you need to fine tune the position of the handle labels: QLabeledRangeSlider.label_shift_x : adjust horizontal label position QLabeledRangeSlider.label_shift_y : adjust vertical label position","title":"QLabeledRangeSlider"},{"location":"widgets/qlabeledrangeslider/#qlabeledrangeslider","text":"Labeled variant of QRangeSlider . (see that page for more details). from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledRangeSlider app = QApplication ([]) slider = QLabeledRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ ()","title":"QLabeledRangeSlider"},{"location":"widgets/qlabeledrangeslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeledrangeslider/#signals","text":"","title":"Signals"},{"location":"widgets/qlabeledrangeslider/#editingfinished","text":"","title":"editingFinished"},{"location":"widgets/qlabeledrangeslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeledrangeslider/#qlabeledrangesliderlabelposition","text":"NoLabel LabelsAbove LabelsBelow","title":"QLabeledRangeSlider.LabelPosition"},{"location":"widgets/qlabeledrangeslider/#qlabeledrangeslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledRangeSlider.EdgeLabelMode"},{"location":"widgets/qlabeledrangeslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.edgeLabelMode","text":"Return current EdgeLabelMode .","title":"edgeLabelMode()"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.handleLabelPosition","text":"Return where/whether labels are shown adjacent to slider handles.","title":"handleLabelPosition()"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.setEdgeLabelMode","text":"Set EdgeLabelMode , controls what is shown at the min/max labels.","title":"setEdgeLabelMode()"},{"location":"widgets/qlabeledrangeslider/#superqt.sliders._labeled.QLabeledRangeSlider.setHandleLabelPosition","text":"Set where/whether labels are shown adjacent to slider handles. If you find that you need to fine tune the position of the handle labels: QLabeledRangeSlider.label_shift_x : adjust horizontal label position QLabeledRangeSlider.label_shift_y : adjust vertical label position","title":"setHandleLabelPosition()"},{"location":"widgets/qlabeledslider/","text":"QLabeledSlider QSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledSlider app = QApplication ([]) slider = QLabeledSlider ( Qt . Orientation . Horizontal ) slider . setValue ( 42 ) slider . show () app . exec_ () Qt Class QAbstractSlider Signals editingFinished Enums QLabeledSlider.EdgeLabelMode NoLabel LabelIsRange LabelIsValue Methods edgeLabelMode () -> EdgeLabelMode Return current EdgeLabelMode . setEdgeLabelMode ( opt : EdgeLabelMode ) -> None Set the EdgeLabelMode .","title":"QLabeledSlider"},{"location":"widgets/qlabeledslider/#qlabeledslider","text":"QSlider variant that shows an editable (SpinBox) label next to the slider. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLabeledSlider app = QApplication ([]) slider = QLabeledSlider ( Qt . Orientation . Horizontal ) slider . setValue ( 42 ) slider . show () app . exec_ ()","title":"QLabeledSlider"},{"location":"widgets/qlabeledslider/#qt-class","text":"QAbstractSlider","title":"Qt Class"},{"location":"widgets/qlabeledslider/#signals","text":"","title":"Signals"},{"location":"widgets/qlabeledslider/#editingfinished","text":"","title":"editingFinished"},{"location":"widgets/qlabeledslider/#enums","text":"","title":"Enums"},{"location":"widgets/qlabeledslider/#qlabeledslideredgelabelmode","text":"NoLabel LabelIsRange LabelIsValue","title":"QLabeledSlider.EdgeLabelMode"},{"location":"widgets/qlabeledslider/#methods","text":"","title":"Methods"},{"location":"widgets/qlabeledslider/#superqt.sliders._labeled.QLabeledSlider.edgeLabelMode","text":"Return current EdgeLabelMode .","title":"edgeLabelMode()"},{"location":"widgets/qlabeledslider/#superqt.sliders._labeled.QLabeledSlider.setEdgeLabelMode","text":"Set the EdgeLabelMode .","title":"setEdgeLabelMode()"},{"location":"widgets/qlargeintspinbox/","text":"QLargeIntSpinBox QSpinBox variant that allows to enter large integers, without overflow. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLargeIntSpinBox app = QApplication ([]) slider = QLargeIntSpinBox () slider . setRange ( 0 , 4.53e8 ) slider . setValue ( 4.53e8 ) slider . show () app . exec_ () Qt Class QAbstractSpinBox Signals textChanged valueChanged Methods An integer spinboxes backed by unbound python integer Qt's built-in QSpinBox is backed by a signed 32-bit integer. This could become limiting, particularly in large dense segmentations. This class behaves like a QSpinBox backed by an unbound python int. Does not yet support \"prefix\", \"suffix\" or \"specialValue\" like QSpinBox. maximum () minimum () setMaximum ( max ) setMinimum ( min ) setRange ( minimum , maximum ) setSingleStep ( step ) setValue ( value ) singleStep () value ()","title":"QLargeIntSpinBox"},{"location":"widgets/qlargeintspinbox/#qlargeintspinbox","text":"QSpinBox variant that allows to enter large integers, without overflow. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QLargeIntSpinBox app = QApplication ([]) slider = QLargeIntSpinBox () slider . setRange ( 0 , 4.53e8 ) slider . setValue ( 4.53e8 ) slider . show () app . exec_ ()","title":"QLargeIntSpinBox"},{"location":"widgets/qlargeintspinbox/#qt-class","text":"QAbstractSpinBox","title":"Qt Class"},{"location":"widgets/qlargeintspinbox/#signals","text":"","title":"Signals"},{"location":"widgets/qlargeintspinbox/#textchanged","text":"","title":"textChanged"},{"location":"widgets/qlargeintspinbox/#valuechanged","text":"","title":"valueChanged"},{"location":"widgets/qlargeintspinbox/#methods","text":"An integer spinboxes backed by unbound python integer Qt's built-in QSpinBox is backed by a signed 32-bit integer. This could become limiting, particularly in large dense segmentations. This class behaves like a QSpinBox backed by an unbound python int. Does not yet support \"prefix\", \"suffix\" or \"specialValue\" like QSpinBox.","title":"Methods"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.maximum","text":"","title":"maximum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.minimum","text":"","title":"minimum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setMaximum","text":"","title":"setMaximum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setMinimum","text":"","title":"setMinimum()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setRange","text":"","title":"setRange()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setSingleStep","text":"","title":"setSingleStep()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.setValue","text":"","title":"setValue()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.singleStep","text":"","title":"singleStep()"},{"location":"widgets/qlargeintspinbox/#superqt.spinbox._intspin.QLargeIntSpinBox.value","text":"","title":"value()"},{"location":"widgets/qrangeslider/","text":"QRangeSlider A multi-handle slider widget than can be used to select a range of values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QRangeSlider app = QApplication ([]) slider = QRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ () QRangeSlider inherits from QSlider and attempts to match the Qt API as closely as possible It uses platform-specific styles (for handle, groove, & ticks) but also supports QSS style sheets. Supports mouse wheel events Supports more than 2 handles (e.g. slider.setValue([0, 10, 60, 80]) ) As QRangeSlider inherits from QtWidgets.QSlider , you can use all of the same methods available in the QSlider API . The major difference is that value() and sliderPosition() are reimplemented as tuples of int (where the length of the tuple is equal to the number of handles in the slider.) These options are in addition to the Qt QSlider API, and control the behavior of the bar between handles. getter setter type default description barIsVisible setBarIsVisible hideBar / showBar bool True Whether the bar between handles is visible. barMovesAllHandles setBarMovesAllHandles bool True Whether clicking on the bar moves all handles or just the nearest barIsRigid setBarIsRigid bool True Whether bar length is constant or \"elastic\" when dragging the bar beyond min/max. Screenshots code that generates the images below import os from qtpy import QtCore from qtpy import QtWidgets as QtW # patch for Qt 5.15 on macos >= 12 os . environ [ \"USE_MAC_SLIDER_PATCH\" ] = \"1\" from superqt import QRangeSlider # noqa QSS = \"\"\" QSlider { min-height: 20px; } QSlider::groove:horizontal { border: 0px; background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #888, stop:1 #ddd); height: 20px; border-radius: 10px; } QSlider::handle { background: qradialgradient(cx:0, cy:0, radius: 1.2, fx:0.35, fy:0.3, stop:0 #eef, stop:1 #002); height: 20px; width: 20px; border-radius: 10px; } QSlider::sub-page:horizontal { background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); border-top-left-radius: 10px; border-bottom-left-radius: 10px; } QRangeSlider { qproperty-barColor: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); } \"\"\" Horizontal = QtCore . Qt . Orientation . Horizontal class DemoWidget ( QtW . QWidget ): def __init__ ( self ) -> None : super () . __init__ () reg_hslider = QtW . QSlider ( Horizontal ) reg_hslider . setValue ( 50 ) range_hslider = QRangeSlider ( Horizontal ) range_hslider . setValue (( 20 , 80 )) multi_range_hslider = QRangeSlider ( Horizontal ) multi_range_hslider . setValue (( 11 , 33 , 66 , 88 )) multi_range_hslider . setTickPosition ( QtW . QSlider . TickPosition . TicksAbove ) styled_reg_hslider = QtW . QSlider ( Horizontal ) styled_reg_hslider . setValue ( 50 ) styled_reg_hslider . setStyleSheet ( QSS ) styled_range_hslider = QRangeSlider ( Horizontal ) styled_range_hslider . setValue (( 20 , 80 )) styled_range_hslider . setStyleSheet ( QSS ) reg_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) reg_vslider . setValue ( 50 ) range_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_vslider . setValue (( 22 , 77 )) tick_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) tick_vslider . setValue ( 55 ) tick_vslider . setTickPosition ( QtW . QSlider . TicksRight ) range_tick_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_tick_vslider . setValue (( 22 , 77 )) range_tick_vslider . setTickPosition ( QtW . QSlider . TicksLeft ) szp = QtW . QSizePolicy . Maximum left = QtW . QWidget () left . setLayout ( QtW . QVBoxLayout ()) left . setContentsMargins ( 2 , 2 , 2 , 2 ) label1 = QtW . QLabel ( \"Regular QSlider Unstyled\" ) label2 = QtW . QLabel ( \"QRangeSliders Unstyled\" ) label3 = QtW . QLabel ( \"Styled Sliders (using same stylesheet)\" ) label1 . setSizePolicy ( szp , szp ) label2 . setSizePolicy ( szp , szp ) label3 . setSizePolicy ( szp , szp ) left . layout () . addWidget ( label1 ) left . layout () . addWidget ( reg_hslider ) left . layout () . addWidget ( label2 ) left . layout () . addWidget ( range_hslider ) left . layout () . addWidget ( multi_range_hslider ) left . layout () . addWidget ( label3 ) left . layout () . addWidget ( styled_reg_hslider ) left . layout () . addWidget ( styled_range_hslider ) right = QtW . QWidget () right . setLayout ( QtW . QHBoxLayout ()) right . setContentsMargins ( 15 , 5 , 5 , 0 ) right . layout () . setSpacing ( 30 ) right . layout () . addWidget ( reg_vslider ) right . layout () . addWidget ( range_vslider ) right . layout () . addWidget ( tick_vslider ) right . layout () . addWidget ( range_tick_vslider ) self . setLayout ( QtW . QHBoxLayout ()) self . layout () . addWidget ( left ) self . layout () . addWidget ( right ) self . setGeometry ( 600 , 300 , 580 , 300 ) self . activateWindow () self . show () if __name__ == \"__main__\" : import sys from pathlib import Path dest = Path ( \"screenshots\" ) dest . mkdir ( exist_ok = True ) app = QtW . QApplication ([]) demo = DemoWidget () if \"-snap\" in sys . argv : import platform QtW . QApplication . processEvents () demo . grab () . save ( str ( dest / f \"demo_ { platform . system () . lower () } .png\" )) else : app . exec_ () macOS Catalina Big Sur Windows Linux Qt Class QSlider Methods MultiHandle Range Slider widget. Same API as QSlider, but value , setValue , sliderPosition , and setSliderPosition are all sequences of integers. The valueChanged and sliderMoved signals also both emit a tuple of integers. barColor = Property ( QtGui . QBrush , _getBarColor , _setBarColor ) class-attribute The color of the bar between the first and last handle. applyMacStylePatch () -> str Apply a QSS patch to fix sliders on macos>=12 with QT < 6. see FAQ for more details. barIsRigid () -> bool Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True . barIsVisible () -> bool Whether to show the bar between the first and last handle. barMovesAllHandles () -> bool Whether clicking on the bar moves all handles (default), or just the nearest. hideBar () -> None Hide the bar between the first and last handle. setBarIsRigid ( val : bool = True ) -> None Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True . setBarMovesAllHandles ( val : bool = True ) -> None Whether clicking on the bar moves all handles (default), or just the nearest. setBarVisible ( val : bool = True ) -> None Whether to show the bar between the first and last handle. showBar () -> None Show the bar between the first and last handle. Type changes Note the following changes in types compared to the QSlider API: value () -> Tuple [ int , ... ] setValue ( val : Sequence [ int ]) -> None # Signal valueChanged ( Tuple [ int , ... ]) sliderPosition () -> Tuple [ int , ... ] setSliderPosition ( val : Sequence [ int ]) -> None sliderMoved ( Tuple [ int , ... ])","title":"QRangeSlider"},{"location":"widgets/qrangeslider/#qrangeslider","text":"A multi-handle slider widget than can be used to select a range of values. from qtpy.QtCore import Qt from qtpy.QtWidgets import QApplication from superqt import QRangeSlider app = QApplication ([]) slider = QRangeSlider ( Qt . Orientation . Horizontal ) slider . setValue (( 20 , 80 )) slider . show () app . exec_ () QRangeSlider inherits from QSlider and attempts to match the Qt API as closely as possible It uses platform-specific styles (for handle, groove, & ticks) but also supports QSS style sheets. Supports mouse wheel events Supports more than 2 handles (e.g. slider.setValue([0, 10, 60, 80]) ) As QRangeSlider inherits from QtWidgets.QSlider , you can use all of the same methods available in the QSlider API . The major difference is that value() and sliderPosition() are reimplemented as tuples of int (where the length of the tuple is equal to the number of handles in the slider.) These options are in addition to the Qt QSlider API, and control the behavior of the bar between handles. getter setter type default description barIsVisible setBarIsVisible hideBar / showBar bool True Whether the bar between handles is visible. barMovesAllHandles setBarMovesAllHandles bool True Whether clicking on the bar moves all handles or just the nearest barIsRigid setBarIsRigid bool True Whether bar length is constant or \"elastic\" when dragging the bar beyond min/max.","title":"QRangeSlider"},{"location":"widgets/qrangeslider/#screenshots","text":"code that generates the images below import os from qtpy import QtCore from qtpy import QtWidgets as QtW # patch for Qt 5.15 on macos >= 12 os . environ [ \"USE_MAC_SLIDER_PATCH\" ] = \"1\" from superqt import QRangeSlider # noqa QSS = \"\"\" QSlider { min-height: 20px; } QSlider::groove:horizontal { border: 0px; background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #888, stop:1 #ddd); height: 20px; border-radius: 10px; } QSlider::handle { background: qradialgradient(cx:0, cy:0, radius: 1.2, fx:0.35, fy:0.3, stop:0 #eef, stop:1 #002); height: 20px; width: 20px; border-radius: 10px; } QSlider::sub-page:horizontal { background: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); border-top-left-radius: 10px; border-bottom-left-radius: 10px; } QRangeSlider { qproperty-barColor: qlineargradient(x1:0, y1:0, x2:1, y2:1, stop:0 #227, stop:1 #77a); } \"\"\" Horizontal = QtCore . Qt . Orientation . Horizontal class DemoWidget ( QtW . QWidget ): def __init__ ( self ) -> None : super () . __init__ () reg_hslider = QtW . QSlider ( Horizontal ) reg_hslider . setValue ( 50 ) range_hslider = QRangeSlider ( Horizontal ) range_hslider . setValue (( 20 , 80 )) multi_range_hslider = QRangeSlider ( Horizontal ) multi_range_hslider . setValue (( 11 , 33 , 66 , 88 )) multi_range_hslider . setTickPosition ( QtW . QSlider . TickPosition . TicksAbove ) styled_reg_hslider = QtW . QSlider ( Horizontal ) styled_reg_hslider . setValue ( 50 ) styled_reg_hslider . setStyleSheet ( QSS ) styled_range_hslider = QRangeSlider ( Horizontal ) styled_range_hslider . setValue (( 20 , 80 )) styled_range_hslider . setStyleSheet ( QSS ) reg_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) reg_vslider . setValue ( 50 ) range_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_vslider . setValue (( 22 , 77 )) tick_vslider = QtW . QSlider ( QtCore . Qt . Orientation . Vertical ) tick_vslider . setValue ( 55 ) tick_vslider . setTickPosition ( QtW . QSlider . TicksRight ) range_tick_vslider = QRangeSlider ( QtCore . Qt . Orientation . Vertical ) range_tick_vslider . setValue (( 22 , 77 )) range_tick_vslider . setTickPosition ( QtW . QSlider . TicksLeft ) szp = QtW . QSizePolicy . Maximum left = QtW . QWidget () left . setLayout ( QtW . QVBoxLayout ()) left . setContentsMargins ( 2 , 2 , 2 , 2 ) label1 = QtW . QLabel ( \"Regular QSlider Unstyled\" ) label2 = QtW . QLabel ( \"QRangeSliders Unstyled\" ) label3 = QtW . QLabel ( \"Styled Sliders (using same stylesheet)\" ) label1 . setSizePolicy ( szp , szp ) label2 . setSizePolicy ( szp , szp ) label3 . setSizePolicy ( szp , szp ) left . layout () . addWidget ( label1 ) left . layout () . addWidget ( reg_hslider ) left . layout () . addWidget ( label2 ) left . layout () . addWidget ( range_hslider ) left . layout () . addWidget ( multi_range_hslider ) left . layout () . addWidget ( label3 ) left . layout () . addWidget ( styled_reg_hslider ) left . layout () . addWidget ( styled_range_hslider ) right = QtW . QWidget () right . setLayout ( QtW . QHBoxLayout ()) right . setContentsMargins ( 15 , 5 , 5 , 0 ) right . layout () . setSpacing ( 30 ) right . layout () . addWidget ( reg_vslider ) right . layout () . addWidget ( range_vslider ) right . layout () . addWidget ( tick_vslider ) right . layout () . addWidget ( range_tick_vslider ) self . setLayout ( QtW . QHBoxLayout ()) self . layout () . addWidget ( left ) self . layout () . addWidget ( right ) self . setGeometry ( 600 , 300 , 580 , 300 ) self . activateWindow () self . show () if __name__ == \"__main__\" : import sys from pathlib import Path dest = Path ( \"screenshots\" ) dest . mkdir ( exist_ok = True ) app = QtW . QApplication ([]) demo = DemoWidget () if \"-snap\" in sys . argv : import platform QtW . QApplication . processEvents () demo . grab () . save ( str ( dest / f \"demo_ { platform . system () . lower () } .png\" )) else : app . exec_ ()","title":"Screenshots"},{"location":"widgets/qrangeslider/#macos","text":"","title":"macOS"},{"location":"widgets/qrangeslider/#catalina","text":"","title":"Catalina"},{"location":"widgets/qrangeslider/#big-sur","text":"","title":"Big Sur"},{"location":"widgets/qrangeslider/#windows","text":"","title":"Windows"},{"location":"widgets/qrangeslider/#linux","text":"","title":"Linux"},{"location":"widgets/qrangeslider/#qt-class","text":"QSlider","title":"Qt Class"},{"location":"widgets/qrangeslider/#methods","text":"MultiHandle Range Slider widget. Same API as QSlider, but value , setValue , sliderPosition , and setSliderPosition are all sequences of integers. The valueChanged and sliderMoved signals also both emit a tuple of integers.","title":"Methods"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barColor","text":"The color of the bar between the first and last handle.","title":"barColor"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.applyMacStylePatch","text":"Apply a QSS patch to fix sliders on macos>=12 with QT < 6. see FAQ for more details.","title":"applyMacStylePatch()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barIsRigid","text":"Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True .","title":"barIsRigid()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barIsVisible","text":"Whether to show the bar between the first and last handle.","title":"barIsVisible()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.barMovesAllHandles","text":"Whether clicking on the bar moves all handles (default), or just the nearest.","title":"barMovesAllHandles()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.hideBar","text":"Hide the bar between the first and last handle.","title":"hideBar()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.setBarIsRigid","text":"Whether bar length is constant when dragging the bar. If False , the bar can shorten when dragged beyond min/max. Default is True .","title":"setBarIsRigid()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.setBarMovesAllHandles","text":"Whether clicking on the bar moves all handles (default), or just the nearest.","title":"setBarMovesAllHandles()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.setBarVisible","text":"Whether to show the bar between the first and last handle.","title":"setBarVisible()"},{"location":"widgets/qrangeslider/#superqt.sliders._generic_range_slider._GenericRangeSlider.showBar","text":"Show the bar between the first and last handle.","title":"showBar()"},{"location":"widgets/qrangeslider/#type-changes","text":"Note the following changes in types compared to the QSlider API: value () -> Tuple [ int , ... ] setValue ( val : Sequence [ int ]) -> None # Signal valueChanged ( Tuple [ int , ... ]) sliderPosition () -> Tuple [ int , ... ] setSliderPosition ( val : Sequence [ int ]) -> None sliderMoved ( Tuple [ int , ... ])","title":"Type changes"},{"location":"widgets/qsearchablecombobox/","text":"QSearchableComboBox QSearchableComboBox is a variant of QComboBox that allow to filter list of options by enter part of text. It could be drop in replacement for QComboBox . from qtpy.QtWidgets import QApplication from superqt import QSearchableComboBox app = QApplication ([]) combo = QSearchableComboBox () combo . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) combo . show () app . exec_ () Qt Class QComboBox","title":"QSearchableComboBox"},{"location":"widgets/qsearchablecombobox/#qsearchablecombobox","text":"QSearchableComboBox is a variant of QComboBox that allow to filter list of options by enter part of text. It could be drop in replacement for QComboBox . from qtpy.QtWidgets import QApplication from superqt import QSearchableComboBox app = QApplication ([]) combo = QSearchableComboBox () combo . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) combo . show () app . exec_ ()","title":"QSearchableComboBox"},{"location":"widgets/qsearchablecombobox/#qt-class","text":"QComboBox","title":"Qt Class"},{"location":"widgets/qsearchablelistwidget/","text":"QSearchableListWidget QSearchableListWidget is a variant of QListWidget that add text entry above list widget that allow to filter list of available options. Due to implementation details, this widget it does not inherit directly from QListWidget but it does fully satisfy its api. The only limitation is that it cannot be used as argument of QListWidgetItem constructor. from qtpy.QtWidgets import QApplication from superqt import QSearchableListWidget app = QApplication ([]) slider = QSearchableListWidget () slider . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) slider . show () app . exec_ () Qt Class QWidget Methods addItem ( * args ) addItems ( * args ) insertItem ( * args ) insertItems ( * args ) update_visible ( text )","title":"QSearchableListWidget"},{"location":"widgets/qsearchablelistwidget/#qsearchablelistwidget","text":"QSearchableListWidget is a variant of QListWidget that add text entry above list widget that allow to filter list of available options. Due to implementation details, this widget it does not inherit directly from QListWidget but it does fully satisfy its api. The only limitation is that it cannot be used as argument of QListWidgetItem constructor. from qtpy.QtWidgets import QApplication from superqt import QSearchableListWidget app = QApplication ([]) slider = QSearchableListWidget () slider . addItems ([ \"foo\" , \"bar\" , \"baz\" , \"foobar\" , \"foobaz\" , \"barbaz\" ]) slider . show () app . exec_ ()","title":"QSearchableListWidget"},{"location":"widgets/qsearchablelistwidget/#qt-class","text":"QWidget","title":"Qt Class"},{"location":"widgets/qsearchablelistwidget/#methods","text":"","title":"Methods"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.addItem","text":"","title":"addItem()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.addItems","text":"","title":"addItems()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.insertItem","text":"","title":"insertItem()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.insertItems","text":"","title":"insertItems()"},{"location":"widgets/qsearchablelistwidget/#superqt.selection._searchable_list_widget.QSearchableListWidget.update_visible","text":"","title":"update_visible()"}]}